{
  "resolvedId": "/Users/yunhao/Project/website/node_modules/.pnpm/@floating-ui+dom@1.6.3/node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "import { rectToClientRect, autoPlacement as autoPlacement$1, shift as shift$1, flip as flip$1, size as size$1, hide as hide$1, arrow as arrow$1, inline as inline$1, limitShift as limitShift$1, computePosition as computePosition$1 } from '@floating-ui/core';\nexport { detectOverflow, offset } from '@floating-ui/core';\nimport { round, createCoords, max, min, floor } from '@floating-ui/utils';\nimport { getComputedStyle, isHTMLElement, isElement, getWindow, isWebKit, getDocumentElement, getNodeName, isOverflowElement, getNodeScroll, getOverflowAncestors, getParentNode, isLastTraversableNode, isContainingBlock, isTableElement, getContainingBlock } from '@floating-ui/utils/dom';\nexport { getOverflowAncestors } from '@floating-ui/utils/dom';\n\nfunction getCssDimensions(element) {\n  const css = getComputedStyle(element);\n  // In testing environments, the `width` and `height` properties are empty\n  // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n  let width = parseFloat(css.width) || 0;\n  let height = parseFloat(css.height) || 0;\n  const hasOffset = isHTMLElement(element);\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    $: shouldFallback\n  };\n}\n\nfunction unwrapElement(element) {\n  return !isElement(element) ? element.contextElement : element;\n}\n\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!isHTMLElement(domElement)) {\n    return createCoords(1);\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    $\n  } = getCssDimensions(domElement);\n  let x = ($ ? round(rect.width) : rect.width) / width;\n  let y = ($ ? round(rect.height) : rect.height) / height;\n\n  // 0, NaN, or Infinity should always fallback to 1.\n\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\n\nconst noOffsets = /*#__PURE__*/createCoords(0);\nfunction getVisualOffsets(element) {\n  const win = getWindow(element);\n  if (!isWebKit() || !win.visualViewport) {\n    return noOffsets;\n  }\n  return {\n    x: win.visualViewport.offsetLeft,\n    y: win.visualViewport.offsetTop\n  };\n}\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {\n    return false;\n  }\n  return isFixed;\n}\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = createCoords(1);\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);\n  let x = (clientRect.left + visualOffsets.x) / scale.x;\n  let y = (clientRect.top + visualOffsets.y) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = getWindow(domElement);\n    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n    let currentWin = win;\n    let currentIFrame = currentWin.frameElement;\n    while (currentIFrame && offsetParent && offsetWin !== currentWin) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = getComputedStyle(currentIFrame);\n      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += left;\n      y += top;\n      currentWin = getWindow(currentIFrame);\n      currentIFrame = currentWin.frameElement;\n    }\n  }\n  return rectToClientRect({\n    width,\n    height,\n    x,\n    y\n  });\n}\n\nconst topLayerSelectors = [':popover-open', ':modal'];\nfunction isTopLayer(floating) {\n  return topLayerSelectors.some(selector => {\n    try {\n      return floating.matches(selector);\n    } catch (e) {\n      return false;\n    }\n  });\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isFixed = strategy === 'fixed';\n  const documentElement = getDocumentElement(offsetParent);\n  const topLayer = elements ? isTopLayer(elements.floating) : false;\n  if (offsetParent === documentElement || topLayer && isFixed) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = createCoords(1);\n  const offsets = createCoords(0);\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y\n  };\n}\n\nfunction getClientRects(element) {\n  return Array.from(element.getClientRects());\n}\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\n\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element) {\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = element.ownerDocument.body;\n  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle(body).direction === 'rtl') {\n    x += max(html.clientWidth, body.clientWidth) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const visualViewportBased = isWebKit();\n    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  let rect;\n  if (clippingAncestor === 'viewport') {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === 'document') {\n    rect = getDocumentRect(getDocumentElement(element));\n  } else if (isElement(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const visualOffsets = getVisualOffsets(element);\n    rect = {\n      ...clippingAncestor,\n      x: clippingAncestor.x - visualOffsets.x,\n      y: clippingAncestor.y - visualOffsets.y\n    };\n  }\n  return rectToClientRect(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n  const parentNode = getParentNode(element);\n  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {\n    return false;\n  }\n  return getComputedStyle(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);\n}\n\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = getOverflowAncestors(element, [], false).filter(el => isElement(el) && getNodeName(el) !== 'body');\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle(element).position === 'fixed';\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle(currentNode);\n    const currentNodeIsContaining = isContainingBlock(currentNode);\n    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {\n      currentContainingBlockComputedStyle = null;\n    }\n    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n    if (shouldDropCurrentNode) {\n      // Drop non-containing blocks.\n      result = result.filter(ancestor => ancestor !== currentNode);\n    } else {\n      // Record last containing block for next iteration.\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\n\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nfunction getDimensions(element) {\n  const {\n    width,\n    height\n  } = getCssDimensions(element);\n  return {\n    width,\n    height\n  };\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const isFixed = strategy === 'fixed';\n  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = createCoords(0);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isOffsetParentAnElement) {\n      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n  const x = rect.left + scroll.scrollLeft - offsets.x;\n  const y = rect.top + scroll.scrollTop - offsets.y;\n  return {\n    x,\n    y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n  if (polyfill) {\n    return polyfill(element);\n  }\n  return element.offsetParent;\n}\n\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element, polyfill) {\n  const window = getWindow(element);\n  if (!isHTMLElement(element) || isTopLayer(element)) {\n    return window;\n  }\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {\n    return window;\n  }\n  return offsetParent || getContainingBlock(element) || window;\n}\n\nconst getElementRects = async function (data) {\n  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n  const getDimensionsFn = this.getDimensions;\n  return {\n    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),\n    floating: {\n      x: 0,\n      y: 0,\n      ...(await getDimensionsFn(data.floating))\n    }\n  };\n};\n\nfunction isRTL(element) {\n  return getComputedStyle(element).direction === 'rtl';\n}\n\nconst platform = {\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  getDocumentElement,\n  getClippingRect,\n  getOffsetParent,\n  getElementRects,\n  getClientRects,\n  getDimensions,\n  getScale,\n  isElement,\n  isRTL\n};\n\n// https://samthor.au/2021/observing-dom/\nfunction observeMove(element, onMove) {\n  let io = null;\n  let timeoutId;\n  const root = getDocumentElement(element);\n  function cleanup() {\n    var _io;\n    clearTimeout(timeoutId);\n    (_io = io) == null || _io.disconnect();\n    io = null;\n  }\n  function refresh(skip, threshold) {\n    if (skip === void 0) {\n      skip = false;\n    }\n    if (threshold === void 0) {\n      threshold = 1;\n    }\n    cleanup();\n    const {\n      left,\n      top,\n      width,\n      height\n    } = element.getBoundingClientRect();\n    if (!skip) {\n      onMove();\n    }\n    if (!width || !height) {\n      return;\n    }\n    const insetTop = floor(top);\n    const insetRight = floor(root.clientWidth - (left + width));\n    const insetBottom = floor(root.clientHeight - (top + height));\n    const insetLeft = floor(left);\n    const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n    const options = {\n      rootMargin,\n      threshold: max(0, min(1, threshold)) || 1\n    };\n    let isFirstUpdate = true;\n    function handleObserve(entries) {\n      const ratio = entries[0].intersectionRatio;\n      if (ratio !== threshold) {\n        if (!isFirstUpdate) {\n          return refresh();\n        }\n        if (!ratio) {\n          timeoutId = setTimeout(() => {\n            refresh(false, 1e-7);\n          }, 100);\n        } else {\n          refresh(false, ratio);\n        }\n      }\n      isFirstUpdate = false;\n    }\n\n    // Older browsers don't support a `document` as the root and will throw an\n    // error.\n    try {\n      io = new IntersectionObserver(handleObserve, {\n        ...options,\n        // Handle <iframe>s\n        root: root.ownerDocument\n      });\n    } catch (e) {\n      io = new IntersectionObserver(handleObserve, options);\n    }\n    io.observe(element);\n  }\n  refresh(true);\n  return cleanup;\n}\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = typeof ResizeObserver === 'function',\n    layoutShift = typeof IntersectionObserver === 'function',\n    animationFrame = false\n  } = options;\n  const referenceEl = unwrapElement(reference);\n  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n  let reobserveFrame = -1;\n  let resizeObserver = null;\n  if (elementResize) {\n    resizeObserver = new ResizeObserver(_ref => {\n      let [firstEntry] = _ref;\n      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n        // Prevent update loops when using the `size` middleware.\n        // https://github.com/floating-ui/floating-ui/issues/1740\n        resizeObserver.unobserve(floating);\n        cancelAnimationFrame(reobserveFrame);\n        reobserveFrame = requestAnimationFrame(() => {\n          var _resizeObserver;\n          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);\n        });\n      }\n      update();\n    });\n    if (referenceEl && !animationFrame) {\n      resizeObserver.observe(referenceEl);\n    }\n    resizeObserver.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    var _resizeObserver2;\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    cleanupIo == null || cleanupIo();\n    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();\n    resizeObserver = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = autoPlacement$1;\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = shift$1;\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = flip$1;\n\n/**\n * Provides data that allows you to change the size of the floating element â€”\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = size$1;\n\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = hide$1;\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = arrow$1;\n\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = inline$1;\n\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = limitShift$1;\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n */\nconst computePosition = (reference, floating, options) => {\n  // This caches the expensive `getClippingElementAncestors` function so that\n  // multiple lifecycle resets re-use the same result. It only lives for a\n  // single call. If other functions become expensive, we can add them as well.\n  const cache = new Map();\n  const mergedOptions = {\n    platform,\n    ...options\n  };\n  const platformWithCache = {\n    ...mergedOptions.platform,\n    _c: cache\n  };\n  return computePosition$1(reference, floating, {\n    ...mergedOptions,\n    platform: platformWithCache\n  });\n};\n\nexport { arrow, autoPlacement, autoUpdate, computePosition, flip, hide, inline, limitShift, platform, shift, size };\n",
      "start": 1756100541709,
      "end": 1756100541740,
      "sourcemaps": null
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1756100541740,
      "end": 1756100541740,
      "order": "pre"
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1756100541740,
      "end": 1756100541740,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1756100541740,
      "end": 1756100541740,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1756100541740,
      "end": 1756100541740,
      "order": "pre"
    },
    {
      "name": "nuxt:client-fallback-auto-id",
      "start": 1756100541740,
      "end": 1756100541740,
      "order": "pre"
    },
    {
      "name": "server-only-component-transform",
      "start": 1756100541740,
      "end": 1756100541740,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1756100541740,
      "end": 1756100541740,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1756100541740,
      "end": 1756100541740,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1756100541740,
      "end": 1756100541740,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1756100541740,
      "end": 1756100541740,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1756100541740,
      "end": 1756100541740,
      "order": "normal"
    },
    {
      "name": "vite:vue-jsx",
      "start": 1756100541740,
      "end": 1756100541740,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1756100541740,
      "end": 1756100541740,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1756100541740,
      "end": 1756100541740,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1756100541740,
      "end": 1756100541741,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1756100541740,
      "end": 1756100541741,
      "order": "normal"
    },
    {
      "name": "nuxt:components:imports",
      "start": 1756100541741,
      "end": 1756100541741,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1756100541741,
      "end": 1756100541741,
      "order": "normal"
    },
    {
      "name": "ssr-styles",
      "start": 1756100541741,
      "end": 1756100541741,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "result": "import { rectToClientRect, autoPlacement as autoPlacement$1, shift as shift$1, flip as flip$1, size as size$1, hide as hide$1, arrow as arrow$1, inline as inline$1, limitShift as limitShift$1, computePosition as computePosition$1 } from \"@floating-ui/core\";\nexport { detectOverflow, offset } from \"@floating-ui/core\";\nimport { round, createCoords, max, min, floor } from \"@floating-ui/utils\";\nimport { getComputedStyle, isHTMLElement, isElement, getWindow, isWebKit, getDocumentElement, getNodeName, isOverflowElement, getNodeScroll, getOverflowAncestors, getParentNode, isLastTraversableNode, isContainingBlock, isTableElement, getContainingBlock } from \"@floating-ui/utils/dom\";\nexport { getOverflowAncestors } from \"@floating-ui/utils/dom\";\nfunction getCssDimensions(element) {\n  const css = getComputedStyle(element);\n  let width = parseFloat(css.width) || 0;\n  let height = parseFloat(css.height) || 0;\n  const hasOffset = isHTMLElement(element);\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    $: shouldFallback\n  };\n}\nfunction unwrapElement(element) {\n  return !isElement(element) ? element.contextElement : element;\n}\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!isHTMLElement(domElement)) {\n    return createCoords(1);\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    $\n  } = getCssDimensions(domElement);\n  let x = ($ ? round(rect.width) : rect.width) / width;\n  let y = ($ ? round(rect.height) : rect.height) / height;\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\nconst noOffsets = /* @__PURE__ */ createCoords(0);\nfunction getVisualOffsets(element) {\n  const win = getWindow(element);\n  if (!isWebKit() || !win.visualViewport) {\n    return noOffsets;\n  }\n  return {\n    x: win.visualViewport.offsetLeft,\n    y: win.visualViewport.offsetTop\n  };\n}\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {\n    return false;\n  }\n  return isFixed;\n}\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = createCoords(1);\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);\n  let x = (clientRect.left + visualOffsets.x) / scale.x;\n  let y = (clientRect.top + visualOffsets.y) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = getWindow(domElement);\n    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n    let currentWin = win;\n    let currentIFrame = currentWin.frameElement;\n    while (currentIFrame && offsetParent && offsetWin !== currentWin) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = getComputedStyle(currentIFrame);\n      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += left;\n      y += top;\n      currentWin = getWindow(currentIFrame);\n      currentIFrame = currentWin.frameElement;\n    }\n  }\n  return rectToClientRect({\n    width,\n    height,\n    x,\n    y\n  });\n}\nconst topLayerSelectors = [\":popover-open\", \":modal\"];\nfunction isTopLayer(floating) {\n  return topLayerSelectors.some((selector) => {\n    try {\n      return floating.matches(selector);\n    } catch (e) {\n      return false;\n    }\n  });\n}\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isFixed = strategy === \"fixed\";\n  const documentElement = getDocumentElement(offsetParent);\n  const topLayer = elements ? isTopLayer(elements.floating) : false;\n  if (offsetParent === documentElement || topLayer && isFixed) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = createCoords(1);\n  const offsets = createCoords(0);\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== \"body\" || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y\n  };\n}\nfunction getClientRects(element) {\n  return Array.from(element.getClientRects());\n}\nfunction getWindowScrollBarX(element) {\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\nfunction getDocumentRect(element) {\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = element.ownerDocument.body;\n  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle(body).direction === \"rtl\") {\n    x += max(html.clientWidth, body.clientWidth) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const visualViewportBased = isWebKit();\n    if (!visualViewportBased || visualViewportBased && strategy === \"fixed\") {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === \"fixed\");\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  let rect;\n  if (clippingAncestor === \"viewport\") {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === \"document\") {\n    rect = getDocumentRect(getDocumentElement(element));\n  } else if (isElement(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const visualOffsets = getVisualOffsets(element);\n    rect = {\n      ...clippingAncestor,\n      x: clippingAncestor.x - visualOffsets.x,\n      y: clippingAncestor.y - visualOffsets.y\n    };\n  }\n  return rectToClientRect(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n  const parentNode = getParentNode(element);\n  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {\n    return false;\n  }\n  return getComputedStyle(parentNode).position === \"fixed\" || hasFixedPositionAncestor(parentNode, stopNode);\n}\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== \"body\");\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle(element).position === \"fixed\";\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle(currentNode);\n    const currentNodeIsContaining = isContainingBlock(currentNode);\n    if (!currentNodeIsContaining && computedStyle.position === \"fixed\") {\n      currentContainingBlockComputedStyle = null;\n    }\n    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === \"static\" && !!currentContainingBlockComputedStyle && [\"absolute\", \"fixed\"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n    if (shouldDropCurrentNode) {\n      result = result.filter((ancestor) => ancestor !== currentNode);\n    } else {\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === \"clippingAncestors\" ? getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\nfunction getDimensions(element) {\n  const {\n    width,\n    height\n  } = getCssDimensions(element);\n  return {\n    width,\n    height\n  };\n}\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const isFixed = strategy === \"fixed\";\n  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = createCoords(0);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== \"body\" || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isOffsetParentAnElement) {\n      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n  const x = rect.left + scroll.scrollLeft - offsets.x;\n  const y = rect.top + scroll.scrollTop - offsets.y;\n  return {\n    x,\n    y,\n    width: rect.width,\n    height: rect.height\n  };\n}\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === \"fixed\") {\n    return null;\n  }\n  if (polyfill) {\n    return polyfill(element);\n  }\n  return element.offsetParent;\n}\nfunction getOffsetParent(element, polyfill) {\n  const window = getWindow(element);\n  if (!isHTMLElement(element) || isTopLayer(element)) {\n    return window;\n  }\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === \"static\") {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n  if (offsetParent && (getNodeName(offsetParent) === \"html\" || getNodeName(offsetParent) === \"body\" && getComputedStyle(offsetParent).position === \"static\" && !isContainingBlock(offsetParent))) {\n    return window;\n  }\n  return offsetParent || getContainingBlock(element) || window;\n}\nconst getElementRects = async function(data) {\n  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n  const getDimensionsFn = this.getDimensions;\n  return {\n    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),\n    floating: {\n      x: 0,\n      y: 0,\n      ...await getDimensionsFn(data.floating)\n    }\n  };\n};\nfunction isRTL(element) {\n  return getComputedStyle(element).direction === \"rtl\";\n}\nconst platform = {\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  getDocumentElement,\n  getClippingRect,\n  getOffsetParent,\n  getElementRects,\n  getClientRects,\n  getDimensions,\n  getScale,\n  isElement,\n  isRTL\n};\nfunction observeMove(element, onMove) {\n  let io = null;\n  let timeoutId;\n  const root = getDocumentElement(element);\n  function cleanup() {\n    var _io;\n    clearTimeout(timeoutId);\n    (_io = io) == null || _io.disconnect();\n    io = null;\n  }\n  function refresh(skip, threshold) {\n    if (skip === void 0) {\n      skip = false;\n    }\n    if (threshold === void 0) {\n      threshold = 1;\n    }\n    cleanup();\n    const {\n      left,\n      top,\n      width,\n      height\n    } = element.getBoundingClientRect();\n    if (!skip) {\n      onMove();\n    }\n    if (!width || !height) {\n      return;\n    }\n    const insetTop = floor(top);\n    const insetRight = floor(root.clientWidth - (left + width));\n    const insetBottom = floor(root.clientHeight - (top + height));\n    const insetLeft = floor(left);\n    const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n    const options = {\n      rootMargin,\n      threshold: max(0, min(1, threshold)) || 1\n    };\n    let isFirstUpdate = true;\n    function handleObserve(entries) {\n      const ratio = entries[0].intersectionRatio;\n      if (ratio !== threshold) {\n        if (!isFirstUpdate) {\n          return refresh();\n        }\n        if (!ratio) {\n          timeoutId = setTimeout(() => {\n            refresh(false, 1e-7);\n          }, 100);\n        } else {\n          refresh(false, ratio);\n        }\n      }\n      isFirstUpdate = false;\n    }\n    try {\n      io = new IntersectionObserver(handleObserve, {\n        ...options,\n        // Handle <iframe>s\n        root: root.ownerDocument\n      });\n    } catch (e) {\n      io = new IntersectionObserver(handleObserve, options);\n    }\n    io.observe(element);\n  }\n  refresh(true);\n  return cleanup;\n}\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = typeof ResizeObserver === \"function\",\n    layoutShift = typeof IntersectionObserver === \"function\",\n    animationFrame = false\n  } = options;\n  const referenceEl = unwrapElement(reference);\n  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach((ancestor) => {\n    ancestorScroll && ancestor.addEventListener(\"scroll\", update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener(\"resize\", update);\n  });\n  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n  let reobserveFrame = -1;\n  let resizeObserver = null;\n  if (elementResize) {\n    resizeObserver = new ResizeObserver((_ref) => {\n      let [firstEntry] = _ref;\n      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n        resizeObserver.unobserve(floating);\n        cancelAnimationFrame(reobserveFrame);\n        reobserveFrame = requestAnimationFrame(() => {\n          var _resizeObserver;\n          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);\n        });\n      }\n      update();\n    });\n    if (referenceEl && !animationFrame) {\n      resizeObserver.observe(referenceEl);\n    }\n    resizeObserver.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    var _resizeObserver2;\n    ancestors.forEach((ancestor) => {\n      ancestorScroll && ancestor.removeEventListener(\"scroll\", update);\n      ancestorResize && ancestor.removeEventListener(\"resize\", update);\n    });\n    cleanupIo == null || cleanupIo();\n    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();\n    resizeObserver = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\nconst autoPlacement = autoPlacement$1;\nconst shift = shift$1;\nconst flip = flip$1;\nconst size = size$1;\nconst hide = hide$1;\nconst arrow = arrow$1;\nconst inline = inline$1;\nconst limitShift = limitShift$1;\nconst computePosition = (reference, floating, options) => {\n  const cache = /* @__PURE__ */ new Map();\n  const mergedOptions = {\n    platform,\n    ...options\n  };\n  const platformWithCache = {\n    ...mergedOptions.platform,\n    _c: cache\n  };\n  return computePosition$1(reference, floating, {\n    ...mergedOptions,\n    platform: platformWithCache\n  });\n};\nexport { arrow, autoPlacement, autoUpdate, computePosition, flip, hide, inline, limitShift, platform, shift, size };\n",
      "start": 1756100541741,
      "end": 1756100543857,
      "order": "normal",
      "sourcemaps": "{\n  \"version\": 3,\n  \"sources\": [\"/Users/yunhao/Project/website/node_modules/.pnpm/@floating-ui+dom@1.6.3/node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs\"],\n  \"sourcesContent\": [\"import { rectToClientRect, autoPlacement as autoPlacement$1, shift as shift$1, flip as flip$1, size as size$1, hide as hide$1, arrow as arrow$1, inline as inline$1, limitShift as limitShift$1, computePosition as computePosition$1 } from '@floating-ui/core';\\nexport { detectOverflow, offset } from '@floating-ui/core';\\nimport { round, createCoords, max, min, floor } from '@floating-ui/utils';\\nimport { getComputedStyle, isHTMLElement, isElement, getWindow, isWebKit, getDocumentElement, getNodeName, isOverflowElement, getNodeScroll, getOverflowAncestors, getParentNode, isLastTraversableNode, isContainingBlock, isTableElement, getContainingBlock } from '@floating-ui/utils/dom';\\nexport { getOverflowAncestors } from '@floating-ui/utils/dom';\\n\\nfunction getCssDimensions(element) {\\n  const css = getComputedStyle(element);\\n  // In testing environments, the `width` and `height` properties are empty\\n  // strings for SVG elements, returning NaN. Fallback to `0` in this case.\\n  let width = parseFloat(css.width) || 0;\\n  let height = parseFloat(css.height) || 0;\\n  const hasOffset = isHTMLElement(element);\\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\\n  if (shouldFallback) {\\n    width = offsetWidth;\\n    height = offsetHeight;\\n  }\\n  return {\\n    width,\\n    height,\\n    $: shouldFallback\\n  };\\n}\\n\\nfunction unwrapElement(element) {\\n  return !isElement(element) ? element.contextElement : element;\\n}\\n\\nfunction getScale(element) {\\n  const domElement = unwrapElement(element);\\n  if (!isHTMLElement(domElement)) {\\n    return createCoords(1);\\n  }\\n  const rect = domElement.getBoundingClientRect();\\n  const {\\n    width,\\n    height,\\n    $\\n  } = getCssDimensions(domElement);\\n  let x = ($ ? round(rect.width) : rect.width) / width;\\n  let y = ($ ? round(rect.height) : rect.height) / height;\\n\\n  // 0, NaN, or Infinity should always fallback to 1.\\n\\n  if (!x || !Number.isFinite(x)) {\\n    x = 1;\\n  }\\n  if (!y || !Number.isFinite(y)) {\\n    y = 1;\\n  }\\n  return {\\n    x,\\n    y\\n  };\\n}\\n\\nconst noOffsets = /*#__PURE__*/createCoords(0);\\nfunction getVisualOffsets(element) {\\n  const win = getWindow(element);\\n  if (!isWebKit() || !win.visualViewport) {\\n    return noOffsets;\\n  }\\n  return {\\n    x: win.visualViewport.offsetLeft,\\n    y: win.visualViewport.offsetTop\\n  };\\n}\\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\\n  if (isFixed === void 0) {\\n    isFixed = false;\\n  }\\n  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {\\n    return false;\\n  }\\n  return isFixed;\\n}\\n\\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\\n  if (includeScale === void 0) {\\n    includeScale = false;\\n  }\\n  if (isFixedStrategy === void 0) {\\n    isFixedStrategy = false;\\n  }\\n  const clientRect = element.getBoundingClientRect();\\n  const domElement = unwrapElement(element);\\n  let scale = createCoords(1);\\n  if (includeScale) {\\n    if (offsetParent) {\\n      if (isElement(offsetParent)) {\\n        scale = getScale(offsetParent);\\n      }\\n    } else {\\n      scale = getScale(element);\\n    }\\n  }\\n  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);\\n  let x = (clientRect.left + visualOffsets.x) / scale.x;\\n  let y = (clientRect.top + visualOffsets.y) / scale.y;\\n  let width = clientRect.width / scale.x;\\n  let height = clientRect.height / scale.y;\\n  if (domElement) {\\n    const win = getWindow(domElement);\\n    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\\n    let currentWin = win;\\n    let currentIFrame = currentWin.frameElement;\\n    while (currentIFrame && offsetParent && offsetWin !== currentWin) {\\n      const iframeScale = getScale(currentIFrame);\\n      const iframeRect = currentIFrame.getBoundingClientRect();\\n      const css = getComputedStyle(currentIFrame);\\n      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\\n      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\\n      x *= iframeScale.x;\\n      y *= iframeScale.y;\\n      width *= iframeScale.x;\\n      height *= iframeScale.y;\\n      x += left;\\n      y += top;\\n      currentWin = getWindow(currentIFrame);\\n      currentIFrame = currentWin.frameElement;\\n    }\\n  }\\n  return rectToClientRect({\\n    width,\\n    height,\\n    x,\\n    y\\n  });\\n}\\n\\nconst topLayerSelectors = [':popover-open', ':modal'];\\nfunction isTopLayer(floating) {\\n  return topLayerSelectors.some(selector => {\\n    try {\\n      return floating.matches(selector);\\n    } catch (e) {\\n      return false;\\n    }\\n  });\\n}\\n\\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\\n  let {\\n    elements,\\n    rect,\\n    offsetParent,\\n    strategy\\n  } = _ref;\\n  const isFixed = strategy === 'fixed';\\n  const documentElement = getDocumentElement(offsetParent);\\n  const topLayer = elements ? isTopLayer(elements.floating) : false;\\n  if (offsetParent === documentElement || topLayer && isFixed) {\\n    return rect;\\n  }\\n  let scroll = {\\n    scrollLeft: 0,\\n    scrollTop: 0\\n  };\\n  let scale = createCoords(1);\\n  const offsets = createCoords(0);\\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\\n      scroll = getNodeScroll(offsetParent);\\n    }\\n    if (isHTMLElement(offsetParent)) {\\n      const offsetRect = getBoundingClientRect(offsetParent);\\n      scale = getScale(offsetParent);\\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\\n      offsets.y = offsetRect.y + offsetParent.clientTop;\\n    }\\n  }\\n  return {\\n    width: rect.width * scale.x,\\n    height: rect.height * scale.y,\\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,\\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y\\n  };\\n}\\n\\nfunction getClientRects(element) {\\n  return Array.from(element.getClientRects());\\n}\\n\\nfunction getWindowScrollBarX(element) {\\n  // If <html> has a CSS width greater than the viewport, then this will be\\n  // incorrect for RTL.\\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\\n}\\n\\n// Gets the entire size of the scrollable document area, even extending outside\\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\\nfunction getDocumentRect(element) {\\n  const html = getDocumentElement(element);\\n  const scroll = getNodeScroll(element);\\n  const body = element.ownerDocument.body;\\n  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\\n  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\\n  const y = -scroll.scrollTop;\\n  if (getComputedStyle(body).direction === 'rtl') {\\n    x += max(html.clientWidth, body.clientWidth) - width;\\n  }\\n  return {\\n    width,\\n    height,\\n    x,\\n    y\\n  };\\n}\\n\\nfunction getViewportRect(element, strategy) {\\n  const win = getWindow(element);\\n  const html = getDocumentElement(element);\\n  const visualViewport = win.visualViewport;\\n  let width = html.clientWidth;\\n  let height = html.clientHeight;\\n  let x = 0;\\n  let y = 0;\\n  if (visualViewport) {\\n    width = visualViewport.width;\\n    height = visualViewport.height;\\n    const visualViewportBased = isWebKit();\\n    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\\n      x = visualViewport.offsetLeft;\\n      y = visualViewport.offsetTop;\\n    }\\n  }\\n  return {\\n    width,\\n    height,\\n    x,\\n    y\\n  };\\n}\\n\\n// Returns the inner client rect, subtracting scrollbars if present.\\nfunction getInnerBoundingClientRect(element, strategy) {\\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\\n  const top = clientRect.top + element.clientTop;\\n  const left = clientRect.left + element.clientLeft;\\n  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);\\n  const width = element.clientWidth * scale.x;\\n  const height = element.clientHeight * scale.y;\\n  const x = left * scale.x;\\n  const y = top * scale.y;\\n  return {\\n    width,\\n    height,\\n    x,\\n    y\\n  };\\n}\\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\\n  let rect;\\n  if (clippingAncestor === 'viewport') {\\n    rect = getViewportRect(element, strategy);\\n  } else if (clippingAncestor === 'document') {\\n    rect = getDocumentRect(getDocumentElement(element));\\n  } else if (isElement(clippingAncestor)) {\\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\\n  } else {\\n    const visualOffsets = getVisualOffsets(element);\\n    rect = {\\n      ...clippingAncestor,\\n      x: clippingAncestor.x - visualOffsets.x,\\n      y: clippingAncestor.y - visualOffsets.y\\n    };\\n  }\\n  return rectToClientRect(rect);\\n}\\nfunction hasFixedPositionAncestor(element, stopNode) {\\n  const parentNode = getParentNode(element);\\n  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {\\n    return false;\\n  }\\n  return getComputedStyle(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);\\n}\\n\\n// A \\\"clipping ancestor\\\" is an `overflow` element with the characteristic of\\n// clipping (or hiding) child elements. This returns all clipping ancestors\\n// of the given element up the tree.\\nfunction getClippingElementAncestors(element, cache) {\\n  const cachedResult = cache.get(element);\\n  if (cachedResult) {\\n    return cachedResult;\\n  }\\n  let result = getOverflowAncestors(element, [], false).filter(el => isElement(el) && getNodeName(el) !== 'body');\\n  let currentContainingBlockComputedStyle = null;\\n  const elementIsFixed = getComputedStyle(element).position === 'fixed';\\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\\n\\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\\n    const computedStyle = getComputedStyle(currentNode);\\n    const currentNodeIsContaining = isContainingBlock(currentNode);\\n    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {\\n      currentContainingBlockComputedStyle = null;\\n    }\\n    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\\n    if (shouldDropCurrentNode) {\\n      // Drop non-containing blocks.\\n      result = result.filter(ancestor => ancestor !== currentNode);\\n    } else {\\n      // Record last containing block for next iteration.\\n      currentContainingBlockComputedStyle = computedStyle;\\n    }\\n    currentNode = getParentNode(currentNode);\\n  }\\n  cache.set(element, result);\\n  return result;\\n}\\n\\n// Gets the maximum area that the element is visible in due to any number of\\n// clipping ancestors.\\nfunction getClippingRect(_ref) {\\n  let {\\n    element,\\n    boundary,\\n    rootBoundary,\\n    strategy\\n  } = _ref;\\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? getClippingElementAncestors(element, this._c) : [].concat(boundary);\\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\\n  const firstClippingAncestor = clippingAncestors[0];\\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\\n    accRect.top = max(rect.top, accRect.top);\\n    accRect.right = min(rect.right, accRect.right);\\n    accRect.bottom = min(rect.bottom, accRect.bottom);\\n    accRect.left = max(rect.left, accRect.left);\\n    return accRect;\\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\\n  return {\\n    width: clippingRect.right - clippingRect.left,\\n    height: clippingRect.bottom - clippingRect.top,\\n    x: clippingRect.left,\\n    y: clippingRect.top\\n  };\\n}\\n\\nfunction getDimensions(element) {\\n  const {\\n    width,\\n    height\\n  } = getCssDimensions(element);\\n  return {\\n    width,\\n    height\\n  };\\n}\\n\\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\\n  const documentElement = getDocumentElement(offsetParent);\\n  const isFixed = strategy === 'fixed';\\n  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\\n  let scroll = {\\n    scrollLeft: 0,\\n    scrollTop: 0\\n  };\\n  const offsets = createCoords(0);\\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\\n      scroll = getNodeScroll(offsetParent);\\n    }\\n    if (isOffsetParentAnElement) {\\n      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\\n      offsets.y = offsetRect.y + offsetParent.clientTop;\\n    } else if (documentElement) {\\n      offsets.x = getWindowScrollBarX(documentElement);\\n    }\\n  }\\n  const x = rect.left + scroll.scrollLeft - offsets.x;\\n  const y = rect.top + scroll.scrollTop - offsets.y;\\n  return {\\n    x,\\n    y,\\n    width: rect.width,\\n    height: rect.height\\n  };\\n}\\n\\nfunction getTrueOffsetParent(element, polyfill) {\\n  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {\\n    return null;\\n  }\\n  if (polyfill) {\\n    return polyfill(element);\\n  }\\n  return element.offsetParent;\\n}\\n\\n// Gets the closest ancestor positioned element. Handles some edge cases,\\n// such as table ancestors and cross browser bugs.\\nfunction getOffsetParent(element, polyfill) {\\n  const window = getWindow(element);\\n  if (!isHTMLElement(element) || isTopLayer(element)) {\\n    return window;\\n  }\\n  let offsetParent = getTrueOffsetParent(element, polyfill);\\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {\\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\\n  }\\n  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {\\n    return window;\\n  }\\n  return offsetParent || getContainingBlock(element) || window;\\n}\\n\\nconst getElementRects = async function (data) {\\n  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\\n  const getDimensionsFn = this.getDimensions;\\n  return {\\n    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),\\n    floating: {\\n      x: 0,\\n      y: 0,\\n      ...(await getDimensionsFn(data.floating))\\n    }\\n  };\\n};\\n\\nfunction isRTL(element) {\\n  return getComputedStyle(element).direction === 'rtl';\\n}\\n\\nconst platform = {\\n  convertOffsetParentRelativeRectToViewportRelativeRect,\\n  getDocumentElement,\\n  getClippingRect,\\n  getOffsetParent,\\n  getElementRects,\\n  getClientRects,\\n  getDimensions,\\n  getScale,\\n  isElement,\\n  isRTL\\n};\\n\\n// https://samthor.au/2021/observing-dom/\\nfunction observeMove(element, onMove) {\\n  let io = null;\\n  let timeoutId;\\n  const root = getDocumentElement(element);\\n  function cleanup() {\\n    var _io;\\n    clearTimeout(timeoutId);\\n    (_io = io) == null || _io.disconnect();\\n    io = null;\\n  }\\n  function refresh(skip, threshold) {\\n    if (skip === void 0) {\\n      skip = false;\\n    }\\n    if (threshold === void 0) {\\n      threshold = 1;\\n    }\\n    cleanup();\\n    const {\\n      left,\\n      top,\\n      width,\\n      height\\n    } = element.getBoundingClientRect();\\n    if (!skip) {\\n      onMove();\\n    }\\n    if (!width || !height) {\\n      return;\\n    }\\n    const insetTop = floor(top);\\n    const insetRight = floor(root.clientWidth - (left + width));\\n    const insetBottom = floor(root.clientHeight - (top + height));\\n    const insetLeft = floor(left);\\n    const rootMargin = -insetTop + \\\"px \\\" + -insetRight + \\\"px \\\" + -insetBottom + \\\"px \\\" + -insetLeft + \\\"px\\\";\\n    const options = {\\n      rootMargin,\\n      threshold: max(0, min(1, threshold)) || 1\\n    };\\n    let isFirstUpdate = true;\\n    function handleObserve(entries) {\\n      const ratio = entries[0].intersectionRatio;\\n      if (ratio !== threshold) {\\n        if (!isFirstUpdate) {\\n          return refresh();\\n        }\\n        if (!ratio) {\\n          timeoutId = setTimeout(() => {\\n            refresh(false, 1e-7);\\n          }, 100);\\n        } else {\\n          refresh(false, ratio);\\n        }\\n      }\\n      isFirstUpdate = false;\\n    }\\n\\n    // Older browsers don't support a `document` as the root and will throw an\\n    // error.\\n    try {\\n      io = new IntersectionObserver(handleObserve, {\\n        ...options,\\n        // Handle <iframe>s\\n        root: root.ownerDocument\\n      });\\n    } catch (e) {\\n      io = new IntersectionObserver(handleObserve, options);\\n    }\\n    io.observe(element);\\n  }\\n  refresh(true);\\n  return cleanup;\\n}\\n\\n/**\\n * Automatically updates the position of the floating element when necessary.\\n * Should only be called when the floating element is mounted on the DOM or\\n * visible on the screen.\\n * @returns cleanup function that should be invoked when the floating element is\\n * removed from the DOM or hidden from the screen.\\n * @see https://floating-ui.com/docs/autoUpdate\\n */\\nfunction autoUpdate(reference, floating, update, options) {\\n  if (options === void 0) {\\n    options = {};\\n  }\\n  const {\\n    ancestorScroll = true,\\n    ancestorResize = true,\\n    elementResize = typeof ResizeObserver === 'function',\\n    layoutShift = typeof IntersectionObserver === 'function',\\n    animationFrame = false\\n  } = options;\\n  const referenceEl = unwrapElement(reference);\\n  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];\\n  ancestors.forEach(ancestor => {\\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\\n      passive: true\\n    });\\n    ancestorResize && ancestor.addEventListener('resize', update);\\n  });\\n  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\\n  let reobserveFrame = -1;\\n  let resizeObserver = null;\\n  if (elementResize) {\\n    resizeObserver = new ResizeObserver(_ref => {\\n      let [firstEntry] = _ref;\\n      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\\n        // Prevent update loops when using the `size` middleware.\\n        // https://github.com/floating-ui/floating-ui/issues/1740\\n        resizeObserver.unobserve(floating);\\n        cancelAnimationFrame(reobserveFrame);\\n        reobserveFrame = requestAnimationFrame(() => {\\n          var _resizeObserver;\\n          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);\\n        });\\n      }\\n      update();\\n    });\\n    if (referenceEl && !animationFrame) {\\n      resizeObserver.observe(referenceEl);\\n    }\\n    resizeObserver.observe(floating);\\n  }\\n  let frameId;\\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\\n  if (animationFrame) {\\n    frameLoop();\\n  }\\n  function frameLoop() {\\n    const nextRefRect = getBoundingClientRect(reference);\\n    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\\n      update();\\n    }\\n    prevRefRect = nextRefRect;\\n    frameId = requestAnimationFrame(frameLoop);\\n  }\\n  update();\\n  return () => {\\n    var _resizeObserver2;\\n    ancestors.forEach(ancestor => {\\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\\n      ancestorResize && ancestor.removeEventListener('resize', update);\\n    });\\n    cleanupIo == null || cleanupIo();\\n    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();\\n    resizeObserver = null;\\n    if (animationFrame) {\\n      cancelAnimationFrame(frameId);\\n    }\\n  };\\n}\\n\\n/**\\n * Optimizes the visibility of the floating element by choosing the placement\\n * that has the most space available automatically, without needing to specify a\\n * preferred placement. Alternative to `flip`.\\n * @see https://floating-ui.com/docs/autoPlacement\\n */\\nconst autoPlacement = autoPlacement$1;\\n\\n/**\\n * Optimizes the visibility of the floating element by shifting it in order to\\n * keep it in view when it will overflow the clipping boundary.\\n * @see https://floating-ui.com/docs/shift\\n */\\nconst shift = shift$1;\\n\\n/**\\n * Optimizes the visibility of the floating element by flipping the `placement`\\n * in order to keep it in view when the preferred placement(s) will overflow the\\n * clipping boundary. Alternative to `autoPlacement`.\\n * @see https://floating-ui.com/docs/flip\\n */\\nconst flip = flip$1;\\n\\n/**\\n * Provides data that allows you to change the size of the floating element â€”\\n * for instance, prevent it from overflowing the clipping boundary or match the\\n * width of the reference element.\\n * @see https://floating-ui.com/docs/size\\n */\\nconst size = size$1;\\n\\n/**\\n * Provides data to hide the floating element in applicable situations, such as\\n * when it is not in the same clipping context as the reference element.\\n * @see https://floating-ui.com/docs/hide\\n */\\nconst hide = hide$1;\\n\\n/**\\n * Provides data to position an inner element of the floating element so that it\\n * appears centered to the reference element.\\n * @see https://floating-ui.com/docs/arrow\\n */\\nconst arrow = arrow$1;\\n\\n/**\\n * Provides improved positioning for inline reference elements that can span\\n * over multiple lines, such as hyperlinks or range selections.\\n * @see https://floating-ui.com/docs/inline\\n */\\nconst inline = inline$1;\\n\\n/**\\n * Built-in `limiter` that will stop `shift()` at a certain point.\\n */\\nconst limitShift = limitShift$1;\\n\\n/**\\n * Computes the `x` and `y` coordinates that will place the floating element\\n * next to a given reference element.\\n */\\nconst computePosition = (reference, floating, options) => {\\n  // This caches the expensive `getClippingElementAncestors` function so that\\n  // multiple lifecycle resets re-use the same result. It only lives for a\\n  // single call. If other functions become expensive, we can add them as well.\\n  const cache = new Map();\\n  const mergedOptions = {\\n    platform,\\n    ...options\\n  };\\n  const platformWithCache = {\\n    ...mergedOptions.platform,\\n    _c: cache\\n  };\\n  return computePosition$1(reference, floating, {\\n    ...mergedOptions,\\n    platform: platformWithCache\\n  });\\n};\\n\\nexport { arrow, autoPlacement, autoUpdate, computePosition, flip, hide, inline, limitShift, platform, shift, size };\\n\"],\n  \"mappings\": \"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\",\n  \"names\": []\n}\n"
    },
    {
      "name": "vite:css-post",
      "start": 1756100543857,
      "end": 1756100543857,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1756100543857,
      "end": 1756100543857,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1756100543857,
      "end": 1756100543857,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1756100543857,
      "end": 1756100543857,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "start": 1756100543857,
      "end": 1756100543857,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1756100543857,
      "end": 1756100543857,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1756100543857,
      "end": 1756100543857,
      "order": "normal"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1756100543857,
      "end": 1756100543858,
      "order": "post"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1756100543857,
      "end": 1756100543858,
      "order": "post"
    },
    {
      "name": "unplugin-vue-components",
      "start": 1756100543858,
      "end": 1756100543858,
      "order": "post"
    },
    {
      "name": "unplugin-vue-components",
      "start": 1756100543858,
      "end": 1756100543858,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1756100543858,
      "end": 1756100543858,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1756100543858,
      "end": 1756100543858,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1756100543858,
      "end": 1756100543858,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1756100543858,
      "end": 1756100543858,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1756100543858,
      "end": 1756100543858,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1756100543858,
      "end": 1756100543858,
      "order": "post"
    },
    {
      "name": "element-plus:transform",
      "start": 1756100543858,
      "end": 1756100543858,
      "order": "post"
    },
    {
      "name": "vant:transform",
      "start": 1756100543858,
      "end": 1756100543858,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-template",
      "start": 1756100543858,
      "end": 1756100543858,
      "order": "post"
    },
    {
      "name": "nuxt:components-loader",
      "start": 1756100543858,
      "end": 1756100543858,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-composables:transform",
      "start": 1756100543858,
      "end": 1756100543858,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1756100543858,
      "end": 1756100543858,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1756100543858,
      "end": 1756100543858,
      "order": "normal"
    }
  ]
}
