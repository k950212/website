{
  "resolvedId": "/Users/yunhao/Project/website/node_modules/.pnpm/vant@4.9.16_vue@3.5.11/node_modules/vant/es/lazyload/vue-lazyload/lazy.mjs",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "import { nextTick } from \"vue\";\nimport { inBrowser, getScrollParent } from \"@vant/use\";\nimport {\n  remove,\n  on,\n  off,\n  throttle,\n  supportWebp,\n  getDPR,\n  getBestSelectionFromSrcset,\n  hasIntersectionObserver,\n  modeType,\n  ImageCache\n} from \"./util.mjs\";\nimport { isObject } from \"../../utils/index.mjs\";\nimport ReactiveListener from \"./listener.mjs\";\nconst DEFAULT_URL = \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\";\nconst DEFAULT_EVENTS = [\n  \"scroll\",\n  \"wheel\",\n  \"mousewheel\",\n  \"resize\",\n  \"animationend\",\n  \"transitionend\",\n  \"touchmove\"\n];\nconst DEFAULT_OBSERVER_OPTIONS = {\n  rootMargin: \"0px\",\n  threshold: 0\n};\nfunction stdin_default() {\n  return class Lazy {\n    constructor({\n      preLoad,\n      error,\n      throttleWait,\n      preLoadTop,\n      dispatchEvent,\n      loading,\n      attempt,\n      silent = true,\n      scale,\n      listenEvents,\n      filter,\n      adapter,\n      observer,\n      observerOptions\n    }) {\n      this.mode = modeType.event;\n      this.listeners = [];\n      this.targetIndex = 0;\n      this.targets = [];\n      this.options = {\n        silent,\n        dispatchEvent: !!dispatchEvent,\n        throttleWait: throttleWait || 200,\n        preLoad: preLoad || 1.3,\n        preLoadTop: preLoadTop || 0,\n        error: error || DEFAULT_URL,\n        loading: loading || DEFAULT_URL,\n        attempt: attempt || 3,\n        scale: scale || getDPR(scale),\n        ListenEvents: listenEvents || DEFAULT_EVENTS,\n        supportWebp: supportWebp(),\n        filter: filter || {},\n        adapter: adapter || {},\n        observer: !!observer,\n        observerOptions: observerOptions || DEFAULT_OBSERVER_OPTIONS\n      };\n      this.initEvent();\n      this.imageCache = new ImageCache({ max: 200 });\n      this.lazyLoadHandler = throttle(\n        this.lazyLoadHandler.bind(this),\n        this.options.throttleWait\n      );\n      this.setMode(this.options.observer ? modeType.observer : modeType.event);\n    }\n    /**\n     * update config\n     * @param  {Object} config params\n     * @return\n     */\n    config(options = {}) {\n      Object.assign(this.options, options);\n    }\n    /**\n     * output listener's load performance\n     * @return {Array}\n     */\n    performance() {\n      return this.listeners.map((item) => item.performance());\n    }\n    /*\n     * add lazy component to queue\n     * @param  {Vue} vm lazy component instance\n     * @return\n     */\n    addLazyBox(vm) {\n      this.listeners.push(vm);\n      if (inBrowser) {\n        this.addListenerTarget(window);\n        this.observer && this.observer.observe(vm.el);\n        if (vm.$el && vm.$el.parentNode) {\n          this.addListenerTarget(vm.$el.parentNode);\n        }\n      }\n    }\n    /*\n     * add image listener to queue\n     * @param  {DOM} el\n     * @param  {object} binding vue directive binding\n     * @param  {vnode} vnode vue directive vnode\n     * @return\n     */\n    add(el, binding, vnode) {\n      if (this.listeners.some((item) => item.el === el)) {\n        this.update(el, binding);\n        return nextTick(this.lazyLoadHandler);\n      }\n      const value = this.valueFormatter(binding.value);\n      let { src } = value;\n      nextTick(() => {\n        src = getBestSelectionFromSrcset(el, this.options.scale) || src;\n        this.observer && this.observer.observe(el);\n        const container = Object.keys(binding.modifiers)[0];\n        let $parent;\n        if (container) {\n          $parent = vnode.context.$refs[container];\n          $parent = $parent ? $parent.$el || $parent : document.getElementById(container);\n        }\n        if (!$parent) {\n          $parent = getScrollParent(el);\n        }\n        const newListener = new ReactiveListener({\n          bindType: binding.arg,\n          $parent,\n          el,\n          src,\n          loading: value.loading,\n          error: value.error,\n          cors: value.cors,\n          elRenderer: this.elRenderer.bind(this),\n          options: this.options,\n          imageCache: this.imageCache\n        });\n        this.listeners.push(newListener);\n        if (inBrowser) {\n          this.addListenerTarget(window);\n          this.addListenerTarget($parent);\n        }\n        this.lazyLoadHandler();\n        nextTick(() => this.lazyLoadHandler());\n      });\n    }\n    /**\n     * update image src\n     * @param  {DOM} el\n     * @param  {object} vue directive binding\n     * @return\n     */\n    update(el, binding, vnode) {\n      const value = this.valueFormatter(binding.value);\n      let { src } = value;\n      src = getBestSelectionFromSrcset(el, this.options.scale) || src;\n      const exist = this.listeners.find((item) => item.el === el);\n      if (!exist) {\n        this.add(el, binding, vnode);\n      } else {\n        exist.update({\n          src,\n          error: value.error,\n          loading: value.loading\n        });\n      }\n      if (this.observer) {\n        this.observer.unobserve(el);\n        this.observer.observe(el);\n      }\n      this.lazyLoadHandler();\n      nextTick(() => this.lazyLoadHandler());\n    }\n    /**\n     * remove listener form list\n     * @param  {DOM} el\n     * @return\n     */\n    remove(el) {\n      if (!el) return;\n      this.observer && this.observer.unobserve(el);\n      const existItem = this.listeners.find((item) => item.el === el);\n      if (existItem) {\n        this.removeListenerTarget(existItem.$parent);\n        this.removeListenerTarget(window);\n        remove(this.listeners, existItem);\n        existItem.$destroy();\n      }\n    }\n    /*\n     * remove lazy components form list\n     * @param  {Vue} vm Vue instance\n     * @return\n     */\n    removeComponent(vm) {\n      if (!vm) return;\n      remove(this.listeners, vm);\n      this.observer && this.observer.unobserve(vm.el);\n      if (vm.$parent && vm.$el.parentNode) {\n        this.removeListenerTarget(vm.$el.parentNode);\n      }\n      this.removeListenerTarget(window);\n    }\n    setMode(mode) {\n      if (!hasIntersectionObserver && mode === modeType.observer) {\n        mode = modeType.event;\n      }\n      this.mode = mode;\n      if (mode === modeType.event) {\n        if (this.observer) {\n          this.listeners.forEach((listener) => {\n            this.observer.unobserve(listener.el);\n          });\n          this.observer = null;\n        }\n        this.targets.forEach((target) => {\n          this.initListen(target.el, true);\n        });\n      } else {\n        this.targets.forEach((target) => {\n          this.initListen(target.el, false);\n        });\n        this.initIntersectionObserver();\n      }\n    }\n    /*\n     *** Private functions ***\n     */\n    /*\n     * add listener target\n     * @param  {DOM} el listener target\n     * @return\n     */\n    addListenerTarget(el) {\n      if (!el) return;\n      let target = this.targets.find((target2) => target2.el === el);\n      if (!target) {\n        target = {\n          el,\n          id: ++this.targetIndex,\n          childrenCount: 1,\n          listened: true\n        };\n        this.mode === modeType.event && this.initListen(target.el, true);\n        this.targets.push(target);\n      } else {\n        target.childrenCount++;\n      }\n      return this.targetIndex;\n    }\n    /*\n     * remove listener target or reduce target childrenCount\n     * @param  {DOM} el or window\n     * @return\n     */\n    removeListenerTarget(el) {\n      this.targets.forEach((target, index) => {\n        if (target.el === el) {\n          target.childrenCount--;\n          if (!target.childrenCount) {\n            this.initListen(target.el, false);\n            this.targets.splice(index, 1);\n            target = null;\n          }\n        }\n      });\n    }\n    /*\n     * add or remove eventlistener\n     * @param  {DOM} el DOM or Window\n     * @param  {boolean} start flag\n     * @return\n     */\n    initListen(el, start) {\n      this.options.ListenEvents.forEach(\n        (evt) => (start ? on : off)(el, evt, this.lazyLoadHandler)\n      );\n    }\n    initEvent() {\n      this.Event = {\n        listeners: {\n          loading: [],\n          loaded: [],\n          error: []\n        }\n      };\n      this.$on = (event, func) => {\n        if (!this.Event.listeners[event]) this.Event.listeners[event] = [];\n        this.Event.listeners[event].push(func);\n      };\n      this.$once = (event, func) => {\n        const on2 = (...args) => {\n          this.$off(event, on2);\n          func.apply(this, args);\n        };\n        this.$on(event, on2);\n      };\n      this.$off = (event, func) => {\n        if (!func) {\n          if (!this.Event.listeners[event]) return;\n          this.Event.listeners[event].length = 0;\n          return;\n        }\n        remove(this.Event.listeners[event], func);\n      };\n      this.$emit = (event, context, inCache) => {\n        if (!this.Event.listeners[event]) return;\n        this.Event.listeners[event].forEach((func) => func(context, inCache));\n      };\n    }\n    /**\n     * find nodes which in viewport and trigger load\n     * @return\n     */\n    lazyLoadHandler() {\n      const freeList = [];\n      this.listeners.forEach((listener) => {\n        if (!listener.el || !listener.el.parentNode) {\n          freeList.push(listener);\n        }\n        const catIn = listener.checkInView();\n        if (!catIn) return;\n        listener.load();\n      });\n      freeList.forEach((item) => {\n        remove(this.listeners, item);\n        item.$destroy();\n      });\n    }\n    /**\n     * init IntersectionObserver\n     * set mode to observer\n     * @return\n     */\n    initIntersectionObserver() {\n      if (!hasIntersectionObserver) {\n        return;\n      }\n      this.observer = new IntersectionObserver(\n        this.observerHandler.bind(this),\n        this.options.observerOptions\n      );\n      if (this.listeners.length) {\n        this.listeners.forEach((listener) => {\n          this.observer.observe(listener.el);\n        });\n      }\n    }\n    /**\n     * init IntersectionObserver\n     * @return\n     */\n    observerHandler(entries) {\n      entries.forEach((entry) => {\n        if (entry.isIntersecting) {\n          this.listeners.forEach((listener) => {\n            if (listener.el === entry.target) {\n              if (listener.state.loaded)\n                return this.observer.unobserve(listener.el);\n              listener.load();\n            }\n          });\n        }\n      });\n    }\n    /**\n     * set element attribute with image'url and state\n     * @param  {object} lazyload listener object\n     * @param  {string} state will be rendered\n     * @param  {bool} inCache  is rendered from cache\n     * @return\n     */\n    elRenderer(listener, state, cache) {\n      if (!listener.el) return;\n      const { el, bindType } = listener;\n      let src;\n      switch (state) {\n        case \"loading\":\n          src = listener.loading;\n          break;\n        case \"error\":\n          src = listener.error;\n          break;\n        default:\n          ({ src } = listener);\n          break;\n      }\n      if (bindType) {\n        el.style[bindType] = 'url(\"' + src + '\")';\n      } else if (el.getAttribute(\"src\") !== src) {\n        el.setAttribute(\"src\", src);\n      }\n      el.setAttribute(\"lazy\", state);\n      this.$emit(state, listener, cache);\n      this.options.adapter[state] && this.options.adapter[state](listener, this.options);\n      if (this.options.dispatchEvent) {\n        const event = new CustomEvent(state, {\n          detail: listener\n        });\n        el.dispatchEvent(event);\n      }\n    }\n    /**\n     * generate loading loaded error image url\n     * @param {string} image's src\n     * @return {object} image's loading, loaded, error url\n     */\n    valueFormatter(value) {\n      let src = value;\n      let { loading, error } = this.options;\n      if (isObject(value)) {\n        if (process.env.NODE_ENV !== \"production\" && !value.src && !this.options.silent) {\n          console.error(\"[@vant/lazyload] miss src with \" + value);\n        }\n        ({ src } = value);\n        loading = value.loading || this.options.loading;\n        error = value.error || this.options.error;\n      }\n      return {\n        src,\n        loading,\n        error\n      };\n    }\n  };\n}\nexport {\n  stdin_default as default\n};\n",
      "start": 1756100544758,
      "end": 1756100544774,
      "sourcemaps": null
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1756100544774,
      "end": 1756100544774,
      "order": "pre"
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1756100544774,
      "end": 1756100544774,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1756100544774,
      "end": 1756100544774,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1756100544774,
      "end": 1756100544774,
      "order": "pre"
    },
    {
      "name": "nuxt:client-fallback-auto-id",
      "start": 1756100544774,
      "end": 1756100544774,
      "order": "pre"
    },
    {
      "name": "server-only-component-transform",
      "start": 1756100544774,
      "end": 1756100544774,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1756100544774,
      "end": 1756100544774,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1756100544774,
      "end": 1756100544774,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1756100544774,
      "end": 1756100544774,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1756100544774,
      "end": 1756100544774,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1756100544774,
      "end": 1756100544774,
      "order": "normal"
    },
    {
      "name": "vite:vue-jsx",
      "start": 1756100544774,
      "end": 1756100544774,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1756100544774,
      "end": 1756100544774,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1756100544774,
      "end": 1756100544774,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1756100544774,
      "end": 1756100544774,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1756100544774,
      "end": 1756100544774,
      "order": "normal"
    },
    {
      "name": "nuxt:components:imports",
      "start": 1756100544774,
      "end": 1756100544774,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1756100544774,
      "end": 1756100544774,
      "order": "normal"
    },
    {
      "name": "ssr-styles",
      "start": 1756100544774,
      "end": 1756100544774,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "result": "import { nextTick } from \"vue\";\nimport { inBrowser, getScrollParent } from \"@vant/use\";\nimport {\n  remove,\n  on,\n  off,\n  throttle,\n  supportWebp,\n  getDPR,\n  getBestSelectionFromSrcset,\n  hasIntersectionObserver,\n  modeType,\n  ImageCache\n} from \"./util.mjs\";\nimport { isObject } from \"../../utils/index.mjs\";\nimport ReactiveListener from \"./listener.mjs\";\nconst DEFAULT_URL = \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\";\nconst DEFAULT_EVENTS = [\n  \"scroll\",\n  \"wheel\",\n  \"mousewheel\",\n  \"resize\",\n  \"animationend\",\n  \"transitionend\",\n  \"touchmove\"\n];\nconst DEFAULT_OBSERVER_OPTIONS = {\n  rootMargin: \"0px\",\n  threshold: 0\n};\nfunction stdin_default() {\n  return class Lazy {\n    constructor({\n      preLoad,\n      error,\n      throttleWait,\n      preLoadTop,\n      dispatchEvent,\n      loading,\n      attempt,\n      silent = true,\n      scale,\n      listenEvents,\n      filter,\n      adapter,\n      observer,\n      observerOptions\n    }) {\n      this.mode = modeType.event;\n      this.listeners = [];\n      this.targetIndex = 0;\n      this.targets = [];\n      this.options = {\n        silent,\n        dispatchEvent: !!dispatchEvent,\n        throttleWait: throttleWait || 200,\n        preLoad: preLoad || 1.3,\n        preLoadTop: preLoadTop || 0,\n        error: error || DEFAULT_URL,\n        loading: loading || DEFAULT_URL,\n        attempt: attempt || 3,\n        scale: scale || getDPR(scale),\n        ListenEvents: listenEvents || DEFAULT_EVENTS,\n        supportWebp: supportWebp(),\n        filter: filter || {},\n        adapter: adapter || {},\n        observer: !!observer,\n        observerOptions: observerOptions || DEFAULT_OBSERVER_OPTIONS\n      };\n      this.initEvent();\n      this.imageCache = new ImageCache({ max: 200 });\n      this.lazyLoadHandler = throttle(\n        this.lazyLoadHandler.bind(this),\n        this.options.throttleWait\n      );\n      this.setMode(this.options.observer ? modeType.observer : modeType.event);\n    }\n    /**\n     * update config\n     * @param  {Object} config params\n     * @return\n     */\n    config(options = {}) {\n      Object.assign(this.options, options);\n    }\n    /**\n     * output listener's load performance\n     * @return {Array}\n     */\n    performance() {\n      return this.listeners.map((item) => item.performance());\n    }\n    /*\n     * add lazy component to queue\n     * @param  {Vue} vm lazy component instance\n     * @return\n     */\n    addLazyBox(vm) {\n      this.listeners.push(vm);\n      if (inBrowser) {\n        this.addListenerTarget(void 0);\n        this.observer && this.observer.observe(vm.el);\n        if (vm.$el && vm.$el.parentNode) {\n          this.addListenerTarget(vm.$el.parentNode);\n        }\n      }\n    }\n    /*\n     * add image listener to queue\n     * @param  {DOM} el\n     * @param  {object} binding vue directive binding\n     * @param  {vnode} vnode vue directive vnode\n     * @return\n     */\n    add(el, binding, vnode) {\n      if (this.listeners.some((item) => item.el === el)) {\n        this.update(el, binding);\n        return nextTick(this.lazyLoadHandler);\n      }\n      const value = this.valueFormatter(binding.value);\n      let { src } = value;\n      nextTick(() => {\n        src = getBestSelectionFromSrcset(el, this.options.scale) || src;\n        this.observer && this.observer.observe(el);\n        const container = Object.keys(binding.modifiers)[0];\n        let $parent;\n        if (container) {\n          $parent = vnode.context.$refs[container];\n          $parent = $parent ? $parent.$el || $parent : (void 0).getElementById(container);\n        }\n        if (!$parent) {\n          $parent = getScrollParent(el);\n        }\n        const newListener = new ReactiveListener({\n          bindType: binding.arg,\n          $parent,\n          el,\n          src,\n          loading: value.loading,\n          error: value.error,\n          cors: value.cors,\n          elRenderer: this.elRenderer.bind(this),\n          options: this.options,\n          imageCache: this.imageCache\n        });\n        this.listeners.push(newListener);\n        if (inBrowser) {\n          this.addListenerTarget(void 0);\n          this.addListenerTarget($parent);\n        }\n        this.lazyLoadHandler();\n        nextTick(() => this.lazyLoadHandler());\n      });\n    }\n    /**\n     * update image src\n     * @param  {DOM} el\n     * @param  {object} vue directive binding\n     * @return\n     */\n    update(el, binding, vnode) {\n      const value = this.valueFormatter(binding.value);\n      let { src } = value;\n      src = getBestSelectionFromSrcset(el, this.options.scale) || src;\n      const exist = this.listeners.find((item) => item.el === el);\n      if (!exist) {\n        this.add(el, binding, vnode);\n      } else {\n        exist.update({\n          src,\n          error: value.error,\n          loading: value.loading\n        });\n      }\n      if (this.observer) {\n        this.observer.unobserve(el);\n        this.observer.observe(el);\n      }\n      this.lazyLoadHandler();\n      nextTick(() => this.lazyLoadHandler());\n    }\n    /**\n     * remove listener form list\n     * @param  {DOM} el\n     * @return\n     */\n    remove(el) {\n      if (!el)\n        return;\n      this.observer && this.observer.unobserve(el);\n      const existItem = this.listeners.find((item) => item.el === el);\n      if (existItem) {\n        this.removeListenerTarget(existItem.$parent);\n        this.removeListenerTarget(void 0);\n        remove(this.listeners, existItem);\n        existItem.$destroy();\n      }\n    }\n    /*\n     * remove lazy components form list\n     * @param  {Vue} vm Vue instance\n     * @return\n     */\n    removeComponent(vm) {\n      if (!vm)\n        return;\n      remove(this.listeners, vm);\n      this.observer && this.observer.unobserve(vm.el);\n      if (vm.$parent && vm.$el.parentNode) {\n        this.removeListenerTarget(vm.$el.parentNode);\n      }\n      this.removeListenerTarget(void 0);\n    }\n    setMode(mode) {\n      if (!hasIntersectionObserver && mode === modeType.observer) {\n        mode = modeType.event;\n      }\n      this.mode = mode;\n      if (mode === modeType.event) {\n        if (this.observer) {\n          this.listeners.forEach((listener) => {\n            this.observer.unobserve(listener.el);\n          });\n          this.observer = null;\n        }\n        this.targets.forEach((target) => {\n          this.initListen(target.el, true);\n        });\n      } else {\n        this.targets.forEach((target) => {\n          this.initListen(target.el, false);\n        });\n        this.initIntersectionObserver();\n      }\n    }\n    /*\n     *** Private functions ***\n     */\n    /*\n     * add listener target\n     * @param  {DOM} el listener target\n     * @return\n     */\n    addListenerTarget(el) {\n      if (!el)\n        return;\n      let target = this.targets.find((target2) => target2.el === el);\n      if (!target) {\n        target = {\n          el,\n          id: ++this.targetIndex,\n          childrenCount: 1,\n          listened: true\n        };\n        this.mode === modeType.event && this.initListen(target.el, true);\n        this.targets.push(target);\n      } else {\n        target.childrenCount++;\n      }\n      return this.targetIndex;\n    }\n    /*\n     * remove listener target or reduce target childrenCount\n     * @param  {DOM} el or window\n     * @return\n     */\n    removeListenerTarget(el) {\n      this.targets.forEach((target, index) => {\n        if (target.el === el) {\n          target.childrenCount--;\n          if (!target.childrenCount) {\n            this.initListen(target.el, false);\n            this.targets.splice(index, 1);\n            target = null;\n          }\n        }\n      });\n    }\n    /*\n     * add or remove eventlistener\n     * @param  {DOM} el DOM or Window\n     * @param  {boolean} start flag\n     * @return\n     */\n    initListen(el, start) {\n      this.options.ListenEvents.forEach(\n        (evt) => (start ? on : off)(el, evt, this.lazyLoadHandler)\n      );\n    }\n    initEvent() {\n      this.Event = {\n        listeners: {\n          loading: [],\n          loaded: [],\n          error: []\n        }\n      };\n      this.$on = (event, func) => {\n        if (!this.Event.listeners[event])\n          this.Event.listeners[event] = [];\n        this.Event.listeners[event].push(func);\n      };\n      this.$once = (event, func) => {\n        const on2 = (...args) => {\n          this.$off(event, on2);\n          func.apply(this, args);\n        };\n        this.$on(event, on2);\n      };\n      this.$off = (event, func) => {\n        if (!func) {\n          if (!this.Event.listeners[event])\n            return;\n          this.Event.listeners[event].length = 0;\n          return;\n        }\n        remove(this.Event.listeners[event], func);\n      };\n      this.$emit = (event, context, inCache) => {\n        if (!this.Event.listeners[event])\n          return;\n        this.Event.listeners[event].forEach((func) => func(context, inCache));\n      };\n    }\n    /**\n     * find nodes which in viewport and trigger load\n     * @return\n     */\n    lazyLoadHandler() {\n      const freeList = [];\n      this.listeners.forEach((listener) => {\n        if (!listener.el || !listener.el.parentNode) {\n          freeList.push(listener);\n        }\n        const catIn = listener.checkInView();\n        if (!catIn)\n          return;\n        listener.load();\n      });\n      freeList.forEach((item) => {\n        remove(this.listeners, item);\n        item.$destroy();\n      });\n    }\n    /**\n     * init IntersectionObserver\n     * set mode to observer\n     * @return\n     */\n    initIntersectionObserver() {\n      if (!hasIntersectionObserver) {\n        return;\n      }\n      this.observer = new IntersectionObserver(\n        this.observerHandler.bind(this),\n        this.options.observerOptions\n      );\n      if (this.listeners.length) {\n        this.listeners.forEach((listener) => {\n          this.observer.observe(listener.el);\n        });\n      }\n    }\n    /**\n     * init IntersectionObserver\n     * @return\n     */\n    observerHandler(entries) {\n      entries.forEach((entry) => {\n        if (entry.isIntersecting) {\n          this.listeners.forEach((listener) => {\n            if (listener.el === entry.target) {\n              if (listener.state.loaded)\n                return this.observer.unobserve(listener.el);\n              listener.load();\n            }\n          });\n        }\n      });\n    }\n    /**\n     * set element attribute with image'url and state\n     * @param  {object} lazyload listener object\n     * @param  {string} state will be rendered\n     * @param  {bool} inCache  is rendered from cache\n     * @return\n     */\n    elRenderer(listener, state, cache) {\n      if (!listener.el)\n        return;\n      const { el, bindType } = listener;\n      let src;\n      switch (state) {\n        case \"loading\":\n          src = listener.loading;\n          break;\n        case \"error\":\n          src = listener.error;\n          break;\n        default:\n          ({ src } = listener);\n          break;\n      }\n      if (bindType) {\n        el.style[bindType] = 'url(\"' + src + '\")';\n      } else if (el.getAttribute(\"src\") !== src) {\n        el.setAttribute(\"src\", src);\n      }\n      el.setAttribute(\"lazy\", state);\n      this.$emit(state, listener, cache);\n      this.options.adapter[state] && this.options.adapter[state](listener, this.options);\n      if (this.options.dispatchEvent) {\n        const event = new CustomEvent(state, {\n          detail: listener\n        });\n        el.dispatchEvent(event);\n      }\n    }\n    /**\n     * generate loading loaded error image url\n     * @param {string} image's src\n     * @return {object} image's loading, loaded, error url\n     */\n    valueFormatter(value) {\n      let src = value;\n      let { loading, error } = this.options;\n      if (isObject(value)) {\n        if (process.env.NODE_ENV !== \"production\" && !value.src && !this.options.silent) {\n          console.error(\"[@vant/lazyload] miss src with \" + value);\n        }\n        ({ src } = value);\n        loading = value.loading || this.options.loading;\n        error = value.error || this.options.error;\n      }\n      return {\n        src,\n        loading,\n        error\n      };\n    }\n  };\n}\nexport {\n  stdin_default as default\n};\n",
      "start": 1756100544774,
      "end": 1756100544982,
      "order": "normal",
      "sourcemaps": "{\n  \"version\": 3,\n  \"sources\": [\"/Users/yunhao/Project/website/node_modules/.pnpm/vant@4.9.16_vue@3.5.11/node_modules/vant/es/lazyload/vue-lazyload/lazy.mjs\"],\n  \"sourcesContent\": [\"import { nextTick } from \\\"vue\\\";\\nimport { inBrowser, getScrollParent } from \\\"@vant/use\\\";\\nimport {\\n  remove,\\n  on,\\n  off,\\n  throttle,\\n  supportWebp,\\n  getDPR,\\n  getBestSelectionFromSrcset,\\n  hasIntersectionObserver,\\n  modeType,\\n  ImageCache\\n} from \\\"./util.mjs\\\";\\nimport { isObject } from \\\"../../utils/index.mjs\\\";\\nimport ReactiveListener from \\\"./listener.mjs\\\";\\nconst DEFAULT_URL = \\\"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\\\";\\nconst DEFAULT_EVENTS = [\\n  \\\"scroll\\\",\\n  \\\"wheel\\\",\\n  \\\"mousewheel\\\",\\n  \\\"resize\\\",\\n  \\\"animationend\\\",\\n  \\\"transitionend\\\",\\n  \\\"touchmove\\\"\\n];\\nconst DEFAULT_OBSERVER_OPTIONS = {\\n  rootMargin: \\\"0px\\\",\\n  threshold: 0\\n};\\nfunction stdin_default() {\\n  return class Lazy {\\n    constructor({\\n      preLoad,\\n      error,\\n      throttleWait,\\n      preLoadTop,\\n      dispatchEvent,\\n      loading,\\n      attempt,\\n      silent = true,\\n      scale,\\n      listenEvents,\\n      filter,\\n      adapter,\\n      observer,\\n      observerOptions\\n    }) {\\n      this.mode = modeType.event;\\n      this.listeners = [];\\n      this.targetIndex = 0;\\n      this.targets = [];\\n      this.options = {\\n        silent,\\n        dispatchEvent: !!dispatchEvent,\\n        throttleWait: throttleWait || 200,\\n        preLoad: preLoad || 1.3,\\n        preLoadTop: preLoadTop || 0,\\n        error: error || DEFAULT_URL,\\n        loading: loading || DEFAULT_URL,\\n        attempt: attempt || 3,\\n        scale: scale || getDPR(scale),\\n        ListenEvents: listenEvents || DEFAULT_EVENTS,\\n        supportWebp: supportWebp(),\\n        filter: filter || {},\\n        adapter: adapter || {},\\n        observer: !!observer,\\n        observerOptions: observerOptions || DEFAULT_OBSERVER_OPTIONS\\n      };\\n      this.initEvent();\\n      this.imageCache = new ImageCache({ max: 200 });\\n      this.lazyLoadHandler = throttle(\\n        this.lazyLoadHandler.bind(this),\\n        this.options.throttleWait\\n      );\\n      this.setMode(this.options.observer ? modeType.observer : modeType.event);\\n    }\\n    /**\\n     * update config\\n     * @param  {Object} config params\\n     * @return\\n     */\\n    config(options = {}) {\\n      Object.assign(this.options, options);\\n    }\\n    /**\\n     * output listener's load performance\\n     * @return {Array}\\n     */\\n    performance() {\\n      return this.listeners.map((item) => item.performance());\\n    }\\n    /*\\n     * add lazy component to queue\\n     * @param  {Vue} vm lazy component instance\\n     * @return\\n     */\\n    addLazyBox(vm) {\\n      this.listeners.push(vm);\\n      if (inBrowser) {\\n        this.addListenerTarget(window);\\n        this.observer && this.observer.observe(vm.el);\\n        if (vm.$el && vm.$el.parentNode) {\\n          this.addListenerTarget(vm.$el.parentNode);\\n        }\\n      }\\n    }\\n    /*\\n     * add image listener to queue\\n     * @param  {DOM} el\\n     * @param  {object} binding vue directive binding\\n     * @param  {vnode} vnode vue directive vnode\\n     * @return\\n     */\\n    add(el, binding, vnode) {\\n      if (this.listeners.some((item) => item.el === el)) {\\n        this.update(el, binding);\\n        return nextTick(this.lazyLoadHandler);\\n      }\\n      const value = this.valueFormatter(binding.value);\\n      let { src } = value;\\n      nextTick(() => {\\n        src = getBestSelectionFromSrcset(el, this.options.scale) || src;\\n        this.observer && this.observer.observe(el);\\n        const container = Object.keys(binding.modifiers)[0];\\n        let $parent;\\n        if (container) {\\n          $parent = vnode.context.$refs[container];\\n          $parent = $parent ? $parent.$el || $parent : document.getElementById(container);\\n        }\\n        if (!$parent) {\\n          $parent = getScrollParent(el);\\n        }\\n        const newListener = new ReactiveListener({\\n          bindType: binding.arg,\\n          $parent,\\n          el,\\n          src,\\n          loading: value.loading,\\n          error: value.error,\\n          cors: value.cors,\\n          elRenderer: this.elRenderer.bind(this),\\n          options: this.options,\\n          imageCache: this.imageCache\\n        });\\n        this.listeners.push(newListener);\\n        if (inBrowser) {\\n          this.addListenerTarget(window);\\n          this.addListenerTarget($parent);\\n        }\\n        this.lazyLoadHandler();\\n        nextTick(() => this.lazyLoadHandler());\\n      });\\n    }\\n    /**\\n     * update image src\\n     * @param  {DOM} el\\n     * @param  {object} vue directive binding\\n     * @return\\n     */\\n    update(el, binding, vnode) {\\n      const value = this.valueFormatter(binding.value);\\n      let { src } = value;\\n      src = getBestSelectionFromSrcset(el, this.options.scale) || src;\\n      const exist = this.listeners.find((item) => item.el === el);\\n      if (!exist) {\\n        this.add(el, binding, vnode);\\n      } else {\\n        exist.update({\\n          src,\\n          error: value.error,\\n          loading: value.loading\\n        });\\n      }\\n      if (this.observer) {\\n        this.observer.unobserve(el);\\n        this.observer.observe(el);\\n      }\\n      this.lazyLoadHandler();\\n      nextTick(() => this.lazyLoadHandler());\\n    }\\n    /**\\n     * remove listener form list\\n     * @param  {DOM} el\\n     * @return\\n     */\\n    remove(el) {\\n      if (!el) return;\\n      this.observer && this.observer.unobserve(el);\\n      const existItem = this.listeners.find((item) => item.el === el);\\n      if (existItem) {\\n        this.removeListenerTarget(existItem.$parent);\\n        this.removeListenerTarget(window);\\n        remove(this.listeners, existItem);\\n        existItem.$destroy();\\n      }\\n    }\\n    /*\\n     * remove lazy components form list\\n     * @param  {Vue} vm Vue instance\\n     * @return\\n     */\\n    removeComponent(vm) {\\n      if (!vm) return;\\n      remove(this.listeners, vm);\\n      this.observer && this.observer.unobserve(vm.el);\\n      if (vm.$parent && vm.$el.parentNode) {\\n        this.removeListenerTarget(vm.$el.parentNode);\\n      }\\n      this.removeListenerTarget(window);\\n    }\\n    setMode(mode) {\\n      if (!hasIntersectionObserver && mode === modeType.observer) {\\n        mode = modeType.event;\\n      }\\n      this.mode = mode;\\n      if (mode === modeType.event) {\\n        if (this.observer) {\\n          this.listeners.forEach((listener) => {\\n            this.observer.unobserve(listener.el);\\n          });\\n          this.observer = null;\\n        }\\n        this.targets.forEach((target) => {\\n          this.initListen(target.el, true);\\n        });\\n      } else {\\n        this.targets.forEach((target) => {\\n          this.initListen(target.el, false);\\n        });\\n        this.initIntersectionObserver();\\n      }\\n    }\\n    /*\\n     *** Private functions ***\\n     */\\n    /*\\n     * add listener target\\n     * @param  {DOM} el listener target\\n     * @return\\n     */\\n    addListenerTarget(el) {\\n      if (!el) return;\\n      let target = this.targets.find((target2) => target2.el === el);\\n      if (!target) {\\n        target = {\\n          el,\\n          id: ++this.targetIndex,\\n          childrenCount: 1,\\n          listened: true\\n        };\\n        this.mode === modeType.event && this.initListen(target.el, true);\\n        this.targets.push(target);\\n      } else {\\n        target.childrenCount++;\\n      }\\n      return this.targetIndex;\\n    }\\n    /*\\n     * remove listener target or reduce target childrenCount\\n     * @param  {DOM} el or window\\n     * @return\\n     */\\n    removeListenerTarget(el) {\\n      this.targets.forEach((target, index) => {\\n        if (target.el === el) {\\n          target.childrenCount--;\\n          if (!target.childrenCount) {\\n            this.initListen(target.el, false);\\n            this.targets.splice(index, 1);\\n            target = null;\\n          }\\n        }\\n      });\\n    }\\n    /*\\n     * add or remove eventlistener\\n     * @param  {DOM} el DOM or Window\\n     * @param  {boolean} start flag\\n     * @return\\n     */\\n    initListen(el, start) {\\n      this.options.ListenEvents.forEach(\\n        (evt) => (start ? on : off)(el, evt, this.lazyLoadHandler)\\n      );\\n    }\\n    initEvent() {\\n      this.Event = {\\n        listeners: {\\n          loading: [],\\n          loaded: [],\\n          error: []\\n        }\\n      };\\n      this.$on = (event, func) => {\\n        if (!this.Event.listeners[event]) this.Event.listeners[event] = [];\\n        this.Event.listeners[event].push(func);\\n      };\\n      this.$once = (event, func) => {\\n        const on2 = (...args) => {\\n          this.$off(event, on2);\\n          func.apply(this, args);\\n        };\\n        this.$on(event, on2);\\n      };\\n      this.$off = (event, func) => {\\n        if (!func) {\\n          if (!this.Event.listeners[event]) return;\\n          this.Event.listeners[event].length = 0;\\n          return;\\n        }\\n        remove(this.Event.listeners[event], func);\\n      };\\n      this.$emit = (event, context, inCache) => {\\n        if (!this.Event.listeners[event]) return;\\n        this.Event.listeners[event].forEach((func) => func(context, inCache));\\n      };\\n    }\\n    /**\\n     * find nodes which in viewport and trigger load\\n     * @return\\n     */\\n    lazyLoadHandler() {\\n      const freeList = [];\\n      this.listeners.forEach((listener) => {\\n        if (!listener.el || !listener.el.parentNode) {\\n          freeList.push(listener);\\n        }\\n        const catIn = listener.checkInView();\\n        if (!catIn) return;\\n        listener.load();\\n      });\\n      freeList.forEach((item) => {\\n        remove(this.listeners, item);\\n        item.$destroy();\\n      });\\n    }\\n    /**\\n     * init IntersectionObserver\\n     * set mode to observer\\n     * @return\\n     */\\n    initIntersectionObserver() {\\n      if (!hasIntersectionObserver) {\\n        return;\\n      }\\n      this.observer = new IntersectionObserver(\\n        this.observerHandler.bind(this),\\n        this.options.observerOptions\\n      );\\n      if (this.listeners.length) {\\n        this.listeners.forEach((listener) => {\\n          this.observer.observe(listener.el);\\n        });\\n      }\\n    }\\n    /**\\n     * init IntersectionObserver\\n     * @return\\n     */\\n    observerHandler(entries) {\\n      entries.forEach((entry) => {\\n        if (entry.isIntersecting) {\\n          this.listeners.forEach((listener) => {\\n            if (listener.el === entry.target) {\\n              if (listener.state.loaded)\\n                return this.observer.unobserve(listener.el);\\n              listener.load();\\n            }\\n          });\\n        }\\n      });\\n    }\\n    /**\\n     * set element attribute with image'url and state\\n     * @param  {object} lazyload listener object\\n     * @param  {string} state will be rendered\\n     * @param  {bool} inCache  is rendered from cache\\n     * @return\\n     */\\n    elRenderer(listener, state, cache) {\\n      if (!listener.el) return;\\n      const { el, bindType } = listener;\\n      let src;\\n      switch (state) {\\n        case \\\"loading\\\":\\n          src = listener.loading;\\n          break;\\n        case \\\"error\\\":\\n          src = listener.error;\\n          break;\\n        default:\\n          ({ src } = listener);\\n          break;\\n      }\\n      if (bindType) {\\n        el.style[bindType] = 'url(\\\"' + src + '\\\")';\\n      } else if (el.getAttribute(\\\"src\\\") !== src) {\\n        el.setAttribute(\\\"src\\\", src);\\n      }\\n      el.setAttribute(\\\"lazy\\\", state);\\n      this.$emit(state, listener, cache);\\n      this.options.adapter[state] && this.options.adapter[state](listener, this.options);\\n      if (this.options.dispatchEvent) {\\n        const event = new CustomEvent(state, {\\n          detail: listener\\n        });\\n        el.dispatchEvent(event);\\n      }\\n    }\\n    /**\\n     * generate loading loaded error image url\\n     * @param {string} image's src\\n     * @return {object} image's loading, loaded, error url\\n     */\\n    valueFormatter(value) {\\n      let src = value;\\n      let { loading, error } = this.options;\\n      if (isObject(value)) {\\n        if (process.env.NODE_ENV !== \\\"production\\\" && !value.src && !this.options.silent) {\\n          console.error(\\\"[@vant/lazyload] miss src with \\\" + value);\\n        }\\n        ({ src } = value);\\n        loading = value.loading || this.options.loading;\\n        error = value.error || this.options.error;\\n      }\\n      return {\\n        src,\\n        loading,\\n        error\\n      };\\n    }\\n  };\\n}\\nexport {\\n  stdin_default as default\\n};\\n\"],\n  \"mappings\": \"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\",\n  \"names\": []\n}\n"
    },
    {
      "name": "vite:css-post",
      "start": 1756100544982,
      "end": 1756100544982,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1756100544982,
      "end": 1756100544982,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1756100544982,
      "end": 1756100544982,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1756100544982,
      "end": 1756100544982,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "start": 1756100544982,
      "end": 1756100544982,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1756100544982,
      "end": 1756100544982,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1756100544982,
      "end": 1756100544982,
      "order": "normal"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1756100544982,
      "end": 1756100544982,
      "order": "post"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1756100544982,
      "end": 1756100544982,
      "order": "post"
    },
    {
      "name": "unplugin-vue-components",
      "start": 1756100544982,
      "end": 1756100544982,
      "order": "post"
    },
    {
      "name": "unplugin-vue-components",
      "start": 1756100544982,
      "end": 1756100544982,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1756100544982,
      "end": 1756100544982,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1756100544982,
      "end": 1756100544982,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1756100544982,
      "end": 1756100544982,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1756100544982,
      "end": 1756100544982,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1756100544982,
      "end": 1756100544982,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1756100544982,
      "end": 1756100544982,
      "order": "post"
    },
    {
      "name": "element-plus:transform",
      "start": 1756100544982,
      "end": 1756100544982,
      "order": "post"
    },
    {
      "name": "vant:transform",
      "start": 1756100544982,
      "end": 1756100544982,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-template",
      "start": 1756100544982,
      "end": 1756100544982,
      "order": "post"
    },
    {
      "name": "nuxt:components-loader",
      "start": 1756100544982,
      "end": 1756100544982,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-composables:transform",
      "start": 1756100544982,
      "end": 1756100544982,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1756100544982,
      "end": 1756100544982,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1756100544982,
      "end": 1756100544982,
      "order": "normal"
    }
  ]
}
