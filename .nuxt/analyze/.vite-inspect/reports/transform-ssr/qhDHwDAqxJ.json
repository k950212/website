{
  "resolvedId": "/Users/yunhao/Project/website/node_modules/.pnpm/swiper@10.3.1/node_modules/swiper/modules/zoom.mjs",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "import { a as getWindow } from '../shared/ssr-window.esm.mjs';\nimport { e as elementChildren, a as elementParents, b as elementOffset, h as getTranslate } from '../shared/utils.mjs';\n\nfunction Zoom(_ref) {\n  let {\n    swiper,\n    extendParams,\n    on,\n    emit\n  } = _ref;\n  const window = getWindow();\n  extendParams({\n    zoom: {\n      enabled: false,\n      maxRatio: 3,\n      minRatio: 1,\n      toggle: true,\n      containerClass: 'swiper-zoom-container',\n      zoomedSlideClass: 'swiper-slide-zoomed'\n    }\n  });\n  swiper.zoom = {\n    enabled: false\n  };\n  let currentScale = 1;\n  let isScaling = false;\n  let fakeGestureTouched;\n  let fakeGestureMoved;\n  const evCache = [];\n  const gesture = {\n    originX: 0,\n    originY: 0,\n    slideEl: undefined,\n    slideWidth: undefined,\n    slideHeight: undefined,\n    imageEl: undefined,\n    imageWrapEl: undefined,\n    maxRatio: 3\n  };\n  const image = {\n    isTouched: undefined,\n    isMoved: undefined,\n    currentX: undefined,\n    currentY: undefined,\n    minX: undefined,\n    minY: undefined,\n    maxX: undefined,\n    maxY: undefined,\n    width: undefined,\n    height: undefined,\n    startX: undefined,\n    startY: undefined,\n    touchesStart: {},\n    touchesCurrent: {}\n  };\n  const velocity = {\n    x: undefined,\n    y: undefined,\n    prevPositionX: undefined,\n    prevPositionY: undefined,\n    prevTime: undefined\n  };\n  let scale = 1;\n  Object.defineProperty(swiper.zoom, 'scale', {\n    get() {\n      return scale;\n    },\n    set(value) {\n      if (scale !== value) {\n        const imageEl = gesture.imageEl;\n        const slideEl = gesture.slideEl;\n        emit('zoomChange', value, imageEl, slideEl);\n      }\n      scale = value;\n    }\n  });\n  function getDistanceBetweenTouches() {\n    if (evCache.length < 2) return 1;\n    const x1 = evCache[0].pageX;\n    const y1 = evCache[0].pageY;\n    const x2 = evCache[1].pageX;\n    const y2 = evCache[1].pageY;\n    const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);\n    return distance;\n  }\n  function getScaleOrigin() {\n    if (evCache.length < 2) return {\n      x: null,\n      y: null\n    };\n    const box = gesture.imageEl.getBoundingClientRect();\n    return [(evCache[0].pageX + (evCache[1].pageX - evCache[0].pageX) / 2 - box.x - window.scrollX) / currentScale, (evCache[0].pageY + (evCache[1].pageY - evCache[0].pageY) / 2 - box.y - window.scrollY) / currentScale];\n  }\n  function getSlideSelector() {\n    return swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;\n  }\n  function eventWithinSlide(e) {\n    const slideSelector = getSlideSelector();\n    if (e.target.matches(slideSelector)) return true;\n    if (swiper.slides.filter(slideEl => slideEl.contains(e.target)).length > 0) return true;\n    return false;\n  }\n  function eventWithinZoomContainer(e) {\n    const selector = `.${swiper.params.zoom.containerClass}`;\n    if (e.target.matches(selector)) return true;\n    if ([...swiper.hostEl.querySelectorAll(selector)].filter(containerEl => containerEl.contains(e.target)).length > 0) return true;\n    return false;\n  }\n\n  // Events\n  function onGestureStart(e) {\n    if (e.pointerType === 'mouse') {\n      evCache.splice(0, evCache.length);\n    }\n    if (!eventWithinSlide(e)) return;\n    const params = swiper.params.zoom;\n    fakeGestureTouched = false;\n    fakeGestureMoved = false;\n    evCache.push(e);\n    if (evCache.length < 2) {\n      return;\n    }\n    fakeGestureTouched = true;\n    gesture.scaleStart = getDistanceBetweenTouches();\n    if (!gesture.slideEl) {\n      gesture.slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);\n      if (!gesture.slideEl) gesture.slideEl = swiper.slides[swiper.activeIndex];\n      let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);\n      if (imageEl) {\n        imageEl = imageEl.querySelectorAll('picture, img, svg, canvas, .swiper-zoom-target')[0];\n      }\n      gesture.imageEl = imageEl;\n      if (imageEl) {\n        gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];\n      } else {\n        gesture.imageWrapEl = undefined;\n      }\n      if (!gesture.imageWrapEl) {\n        gesture.imageEl = undefined;\n        return;\n      }\n      gesture.maxRatio = gesture.imageWrapEl.getAttribute('data-swiper-zoom') || params.maxRatio;\n    }\n    if (gesture.imageEl) {\n      const [originX, originY] = getScaleOrigin();\n      gesture.originX = originX;\n      gesture.originY = originY;\n      gesture.imageEl.style.transitionDuration = '0ms';\n    }\n    isScaling = true;\n  }\n  function onGestureChange(e) {\n    if (!eventWithinSlide(e)) return;\n    const params = swiper.params.zoom;\n    const zoom = swiper.zoom;\n    const pointerIndex = evCache.findIndex(cachedEv => cachedEv.pointerId === e.pointerId);\n    if (pointerIndex >= 0) evCache[pointerIndex] = e;\n    if (evCache.length < 2) {\n      return;\n    }\n    fakeGestureMoved = true;\n    gesture.scaleMove = getDistanceBetweenTouches();\n    if (!gesture.imageEl) {\n      return;\n    }\n    zoom.scale = gesture.scaleMove / gesture.scaleStart * currentScale;\n    if (zoom.scale > gesture.maxRatio) {\n      zoom.scale = gesture.maxRatio - 1 + (zoom.scale - gesture.maxRatio + 1) ** 0.5;\n    }\n    if (zoom.scale < params.minRatio) {\n      zoom.scale = params.minRatio + 1 - (params.minRatio - zoom.scale + 1) ** 0.5;\n    }\n    gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;\n  }\n  function onGestureEnd(e) {\n    if (!eventWithinSlide(e)) return;\n    if (e.pointerType === 'mouse' && e.type === 'pointerout') return;\n    const params = swiper.params.zoom;\n    const zoom = swiper.zoom;\n    const pointerIndex = evCache.findIndex(cachedEv => cachedEv.pointerId === e.pointerId);\n    if (pointerIndex >= 0) evCache.splice(pointerIndex, 1);\n    if (!fakeGestureTouched || !fakeGestureMoved) {\n      return;\n    }\n    fakeGestureTouched = false;\n    fakeGestureMoved = false;\n    if (!gesture.imageEl) return;\n    zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);\n    gesture.imageEl.style.transitionDuration = `${swiper.params.speed}ms`;\n    gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;\n    currentScale = zoom.scale;\n    isScaling = false;\n    if (zoom.scale > 1 && gesture.slideEl) {\n      gesture.slideEl.classList.add(`${params.zoomedSlideClass}`);\n    } else if (zoom.scale <= 1 && gesture.slideEl) {\n      gesture.slideEl.classList.remove(`${params.zoomedSlideClass}`);\n    }\n    if (zoom.scale === 1) {\n      gesture.originX = 0;\n      gesture.originY = 0;\n      gesture.slideEl = undefined;\n    }\n  }\n  function onTouchStart(e) {\n    const device = swiper.device;\n    if (!gesture.imageEl) return;\n    if (image.isTouched) return;\n    if (device.android && e.cancelable) e.preventDefault();\n    image.isTouched = true;\n    const event = evCache.length > 0 ? evCache[0] : e;\n    image.touchesStart.x = event.pageX;\n    image.touchesStart.y = event.pageY;\n  }\n  function onTouchMove(e) {\n    if (!eventWithinSlide(e) || !eventWithinZoomContainer(e)) return;\n    const zoom = swiper.zoom;\n    if (!gesture.imageEl) return;\n    if (!image.isTouched || !gesture.slideEl) return;\n    if (!image.isMoved) {\n      image.width = gesture.imageEl.offsetWidth;\n      image.height = gesture.imageEl.offsetHeight;\n      image.startX = getTranslate(gesture.imageWrapEl, 'x') || 0;\n      image.startY = getTranslate(gesture.imageWrapEl, 'y') || 0;\n      gesture.slideWidth = gesture.slideEl.offsetWidth;\n      gesture.slideHeight = gesture.slideEl.offsetHeight;\n      gesture.imageWrapEl.style.transitionDuration = '0ms';\n    }\n    // Define if we need image drag\n    const scaledWidth = image.width * zoom.scale;\n    const scaledHeight = image.height * zoom.scale;\n    if (scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight) return;\n    image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);\n    image.maxX = -image.minX;\n    image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);\n    image.maxY = -image.minY;\n    image.touchesCurrent.x = evCache.length > 0 ? evCache[0].pageX : e.pageX;\n    image.touchesCurrent.y = evCache.length > 0 ? evCache[0].pageY : e.pageY;\n    const touchesDiff = Math.max(Math.abs(image.touchesCurrent.x - image.touchesStart.x), Math.abs(image.touchesCurrent.y - image.touchesStart.y));\n    if (touchesDiff > 5) {\n      swiper.allowClick = false;\n    }\n    if (!image.isMoved && !isScaling) {\n      if (swiper.isHorizontal() && (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x || Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)) {\n        image.isTouched = false;\n        return;\n      }\n      if (!swiper.isHorizontal() && (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y || Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)) {\n        image.isTouched = false;\n        return;\n      }\n    }\n    if (e.cancelable) {\n      e.preventDefault();\n    }\n    e.stopPropagation();\n    image.isMoved = true;\n    const scaleRatio = (zoom.scale - currentScale) / (gesture.maxRatio - swiper.params.zoom.minRatio);\n    const {\n      originX,\n      originY\n    } = gesture;\n    image.currentX = image.touchesCurrent.x - image.touchesStart.x + image.startX + scaleRatio * (image.width - originX * 2);\n    image.currentY = image.touchesCurrent.y - image.touchesStart.y + image.startY + scaleRatio * (image.height - originY * 2);\n    if (image.currentX < image.minX) {\n      image.currentX = image.minX + 1 - (image.minX - image.currentX + 1) ** 0.8;\n    }\n    if (image.currentX > image.maxX) {\n      image.currentX = image.maxX - 1 + (image.currentX - image.maxX + 1) ** 0.8;\n    }\n    if (image.currentY < image.minY) {\n      image.currentY = image.minY + 1 - (image.minY - image.currentY + 1) ** 0.8;\n    }\n    if (image.currentY > image.maxY) {\n      image.currentY = image.maxY - 1 + (image.currentY - image.maxY + 1) ** 0.8;\n    }\n\n    // Velocity\n    if (!velocity.prevPositionX) velocity.prevPositionX = image.touchesCurrent.x;\n    if (!velocity.prevPositionY) velocity.prevPositionY = image.touchesCurrent.y;\n    if (!velocity.prevTime) velocity.prevTime = Date.now();\n    velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;\n    velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;\n    if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) velocity.x = 0;\n    if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) velocity.y = 0;\n    velocity.prevPositionX = image.touchesCurrent.x;\n    velocity.prevPositionY = image.touchesCurrent.y;\n    velocity.prevTime = Date.now();\n    gesture.imageWrapEl.style.transform = `translate3d(${image.currentX}px, ${image.currentY}px,0)`;\n  }\n  function onTouchEnd() {\n    const zoom = swiper.zoom;\n    if (!gesture.imageEl) return;\n    if (!image.isTouched || !image.isMoved) {\n      image.isTouched = false;\n      image.isMoved = false;\n      return;\n    }\n    image.isTouched = false;\n    image.isMoved = false;\n    let momentumDurationX = 300;\n    let momentumDurationY = 300;\n    const momentumDistanceX = velocity.x * momentumDurationX;\n    const newPositionX = image.currentX + momentumDistanceX;\n    const momentumDistanceY = velocity.y * momentumDurationY;\n    const newPositionY = image.currentY + momentumDistanceY;\n\n    // Fix duration\n    if (velocity.x !== 0) momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);\n    if (velocity.y !== 0) momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);\n    const momentumDuration = Math.max(momentumDurationX, momentumDurationY);\n    image.currentX = newPositionX;\n    image.currentY = newPositionY;\n    // Define if we need image drag\n    const scaledWidth = image.width * zoom.scale;\n    const scaledHeight = image.height * zoom.scale;\n    image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);\n    image.maxX = -image.minX;\n    image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);\n    image.maxY = -image.minY;\n    image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);\n    image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);\n    gesture.imageWrapEl.style.transitionDuration = `${momentumDuration}ms`;\n    gesture.imageWrapEl.style.transform = `translate3d(${image.currentX}px, ${image.currentY}px,0)`;\n  }\n  function onTransitionEnd() {\n    const zoom = swiper.zoom;\n    if (gesture.slideEl && swiper.activeIndex !== swiper.slides.indexOf(gesture.slideEl)) {\n      if (gesture.imageEl) {\n        gesture.imageEl.style.transform = 'translate3d(0,0,0) scale(1)';\n      }\n      if (gesture.imageWrapEl) {\n        gesture.imageWrapEl.style.transform = 'translate3d(0,0,0)';\n      }\n      gesture.slideEl.classList.remove(`${swiper.params.zoom.zoomedSlideClass}`);\n      zoom.scale = 1;\n      currentScale = 1;\n      gesture.slideEl = undefined;\n      gesture.imageEl = undefined;\n      gesture.imageWrapEl = undefined;\n      gesture.originX = 0;\n      gesture.originY = 0;\n    }\n  }\n  function zoomIn(e) {\n    const zoom = swiper.zoom;\n    const params = swiper.params.zoom;\n    if (!gesture.slideEl) {\n      if (e && e.target) {\n        gesture.slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);\n      }\n      if (!gesture.slideEl) {\n        if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {\n          gesture.slideEl = elementChildren(swiper.slidesEl, `.${swiper.params.slideActiveClass}`)[0];\n        } else {\n          gesture.slideEl = swiper.slides[swiper.activeIndex];\n        }\n      }\n      let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);\n      if (imageEl) {\n        imageEl = imageEl.querySelectorAll('picture, img, svg, canvas, .swiper-zoom-target')[0];\n      }\n      gesture.imageEl = imageEl;\n      if (imageEl) {\n        gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];\n      } else {\n        gesture.imageWrapEl = undefined;\n      }\n    }\n    if (!gesture.imageEl || !gesture.imageWrapEl) return;\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.style.overflow = 'hidden';\n      swiper.wrapperEl.style.touchAction = 'none';\n    }\n    gesture.slideEl.classList.add(`${params.zoomedSlideClass}`);\n    let touchX;\n    let touchY;\n    let offsetX;\n    let offsetY;\n    let diffX;\n    let diffY;\n    let translateX;\n    let translateY;\n    let imageWidth;\n    let imageHeight;\n    let scaledWidth;\n    let scaledHeight;\n    let translateMinX;\n    let translateMinY;\n    let translateMaxX;\n    let translateMaxY;\n    let slideWidth;\n    let slideHeight;\n    if (typeof image.touchesStart.x === 'undefined' && e) {\n      touchX = e.pageX;\n      touchY = e.pageY;\n    } else {\n      touchX = image.touchesStart.x;\n      touchY = image.touchesStart.y;\n    }\n    const forceZoomRatio = typeof e === 'number' ? e : null;\n    if (currentScale === 1 && forceZoomRatio) {\n      touchX = undefined;\n      touchY = undefined;\n    }\n    zoom.scale = forceZoomRatio || gesture.imageWrapEl.getAttribute('data-swiper-zoom') || params.maxRatio;\n    currentScale = forceZoomRatio || gesture.imageWrapEl.getAttribute('data-swiper-zoom') || params.maxRatio;\n    if (e && !(currentScale === 1 && forceZoomRatio)) {\n      slideWidth = gesture.slideEl.offsetWidth;\n      slideHeight = gesture.slideEl.offsetHeight;\n      offsetX = elementOffset(gesture.slideEl).left + window.scrollX;\n      offsetY = elementOffset(gesture.slideEl).top + window.scrollY;\n      diffX = offsetX + slideWidth / 2 - touchX;\n      diffY = offsetY + slideHeight / 2 - touchY;\n      imageWidth = gesture.imageEl.offsetWidth;\n      imageHeight = gesture.imageEl.offsetHeight;\n      scaledWidth = imageWidth * zoom.scale;\n      scaledHeight = imageHeight * zoom.scale;\n      translateMinX = Math.min(slideWidth / 2 - scaledWidth / 2, 0);\n      translateMinY = Math.min(slideHeight / 2 - scaledHeight / 2, 0);\n      translateMaxX = -translateMinX;\n      translateMaxY = -translateMinY;\n      translateX = diffX * zoom.scale;\n      translateY = diffY * zoom.scale;\n      if (translateX < translateMinX) {\n        translateX = translateMinX;\n      }\n      if (translateX > translateMaxX) {\n        translateX = translateMaxX;\n      }\n      if (translateY < translateMinY) {\n        translateY = translateMinY;\n      }\n      if (translateY > translateMaxY) {\n        translateY = translateMaxY;\n      }\n    } else {\n      translateX = 0;\n      translateY = 0;\n    }\n    if (forceZoomRatio && zoom.scale === 1) {\n      gesture.originX = 0;\n      gesture.originY = 0;\n    }\n    gesture.imageWrapEl.style.transitionDuration = '300ms';\n    gesture.imageWrapEl.style.transform = `translate3d(${translateX}px, ${translateY}px,0)`;\n    gesture.imageEl.style.transitionDuration = '300ms';\n    gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;\n  }\n  function zoomOut() {\n    const zoom = swiper.zoom;\n    const params = swiper.params.zoom;\n    if (!gesture.slideEl) {\n      if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {\n        gesture.slideEl = elementChildren(swiper.slidesEl, `.${swiper.params.slideActiveClass}`)[0];\n      } else {\n        gesture.slideEl = swiper.slides[swiper.activeIndex];\n      }\n      let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);\n      if (imageEl) {\n        imageEl = imageEl.querySelectorAll('picture, img, svg, canvas, .swiper-zoom-target')[0];\n      }\n      gesture.imageEl = imageEl;\n      if (imageEl) {\n        gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];\n      } else {\n        gesture.imageWrapEl = undefined;\n      }\n    }\n    if (!gesture.imageEl || !gesture.imageWrapEl) return;\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.style.overflow = '';\n      swiper.wrapperEl.style.touchAction = '';\n    }\n    zoom.scale = 1;\n    currentScale = 1;\n    gesture.imageWrapEl.style.transitionDuration = '300ms';\n    gesture.imageWrapEl.style.transform = 'translate3d(0,0,0)';\n    gesture.imageEl.style.transitionDuration = '300ms';\n    gesture.imageEl.style.transform = 'translate3d(0,0,0) scale(1)';\n    gesture.slideEl.classList.remove(`${params.zoomedSlideClass}`);\n    gesture.slideEl = undefined;\n    gesture.originX = 0;\n    gesture.originY = 0;\n  }\n\n  // Toggle Zoom\n  function zoomToggle(e) {\n    const zoom = swiper.zoom;\n    if (zoom.scale && zoom.scale !== 1) {\n      // Zoom Out\n      zoomOut();\n    } else {\n      // Zoom In\n      zoomIn(e);\n    }\n  }\n  function getListeners() {\n    const passiveListener = swiper.params.passiveListeners ? {\n      passive: true,\n      capture: false\n    } : false;\n    const activeListenerWithCapture = swiper.params.passiveListeners ? {\n      passive: false,\n      capture: true\n    } : true;\n    return {\n      passiveListener,\n      activeListenerWithCapture\n    };\n  }\n\n  // Attach/Detach Events\n  function enable() {\n    const zoom = swiper.zoom;\n    if (zoom.enabled) return;\n    zoom.enabled = true;\n    const {\n      passiveListener,\n      activeListenerWithCapture\n    } = getListeners();\n\n    // Scale image\n    swiper.wrapperEl.addEventListener('pointerdown', onGestureStart, passiveListener);\n    swiper.wrapperEl.addEventListener('pointermove', onGestureChange, activeListenerWithCapture);\n    ['pointerup', 'pointercancel', 'pointerout'].forEach(eventName => {\n      swiper.wrapperEl.addEventListener(eventName, onGestureEnd, passiveListener);\n    });\n\n    // Move image\n    swiper.wrapperEl.addEventListener('pointermove', onTouchMove, activeListenerWithCapture);\n  }\n  function disable() {\n    const zoom = swiper.zoom;\n    if (!zoom.enabled) return;\n    zoom.enabled = false;\n    const {\n      passiveListener,\n      activeListenerWithCapture\n    } = getListeners();\n\n    // Scale image\n    swiper.wrapperEl.removeEventListener('pointerdown', onGestureStart, passiveListener);\n    swiper.wrapperEl.removeEventListener('pointermove', onGestureChange, activeListenerWithCapture);\n    ['pointerup', 'pointercancel', 'pointerout'].forEach(eventName => {\n      swiper.wrapperEl.removeEventListener(eventName, onGestureEnd, passiveListener);\n    });\n\n    // Move image\n    swiper.wrapperEl.removeEventListener('pointermove', onTouchMove, activeListenerWithCapture);\n  }\n  on('init', () => {\n    if (swiper.params.zoom.enabled) {\n      enable();\n    }\n  });\n  on('destroy', () => {\n    disable();\n  });\n  on('touchStart', (_s, e) => {\n    if (!swiper.zoom.enabled) return;\n    onTouchStart(e);\n  });\n  on('touchEnd', (_s, e) => {\n    if (!swiper.zoom.enabled) return;\n    onTouchEnd();\n  });\n  on('doubleTap', (_s, e) => {\n    if (!swiper.animating && swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {\n      zoomToggle(e);\n    }\n  });\n  on('transitionEnd', () => {\n    if (swiper.zoom.enabled && swiper.params.zoom.enabled) {\n      onTransitionEnd();\n    }\n  });\n  on('slideChange', () => {\n    if (swiper.zoom.enabled && swiper.params.zoom.enabled && swiper.params.cssMode) {\n      onTransitionEnd();\n    }\n  });\n  Object.assign(swiper.zoom, {\n    enable,\n    disable,\n    in: zoomIn,\n    out: zoomOut,\n    toggle: zoomToggle\n  });\n}\n\nexport { Zoom as default };\n",
      "start": 1756100544556,
      "end": 1756100544595,
      "sourcemaps": null
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1756100544595,
      "end": 1756100544595,
      "order": "pre"
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1756100544595,
      "end": 1756100544595,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1756100544595,
      "end": 1756100544595,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1756100544595,
      "end": 1756100544595,
      "order": "pre"
    },
    {
      "name": "nuxt:client-fallback-auto-id",
      "start": 1756100544595,
      "end": 1756100544595,
      "order": "pre"
    },
    {
      "name": "server-only-component-transform",
      "start": 1756100544595,
      "end": 1756100544595,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1756100544595,
      "end": 1756100544595,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1756100544595,
      "end": 1756100544595,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1756100544595,
      "end": 1756100544595,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1756100544595,
      "end": 1756100544595,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1756100544595,
      "end": 1756100544595,
      "order": "normal"
    },
    {
      "name": "vite:vue-jsx",
      "start": 1756100544595,
      "end": 1756100544595,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1756100544595,
      "end": 1756100544595,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1756100544595,
      "end": 1756100544595,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1756100544595,
      "end": 1756100544595,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1756100544595,
      "end": 1756100544595,
      "order": "normal"
    },
    {
      "name": "nuxt:components:imports",
      "start": 1756100544595,
      "end": 1756100544595,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1756100544595,
      "end": 1756100544595,
      "order": "normal"
    },
    {
      "name": "ssr-styles",
      "start": 1756100544595,
      "end": 1756100544596,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "result": "import { a as getWindow } from \"../shared/ssr-window.esm.mjs\";\nimport { e as elementChildren, a as elementParents, b as elementOffset, h as getTranslate } from \"../shared/utils.mjs\";\nfunction Zoom(_ref) {\n  let {\n    swiper,\n    extendParams,\n    on,\n    emit\n  } = _ref;\n  const window = getWindow();\n  extendParams({\n    zoom: {\n      enabled: false,\n      maxRatio: 3,\n      minRatio: 1,\n      toggle: true,\n      containerClass: \"swiper-zoom-container\",\n      zoomedSlideClass: \"swiper-slide-zoomed\"\n    }\n  });\n  swiper.zoom = {\n    enabled: false\n  };\n  let currentScale = 1;\n  let isScaling = false;\n  let fakeGestureTouched;\n  let fakeGestureMoved;\n  const evCache = [];\n  const gesture = {\n    originX: 0,\n    originY: 0,\n    slideEl: void 0,\n    slideWidth: void 0,\n    slideHeight: void 0,\n    imageEl: void 0,\n    imageWrapEl: void 0,\n    maxRatio: 3\n  };\n  const image = {\n    isTouched: void 0,\n    isMoved: void 0,\n    currentX: void 0,\n    currentY: void 0,\n    minX: void 0,\n    minY: void 0,\n    maxX: void 0,\n    maxY: void 0,\n    width: void 0,\n    height: void 0,\n    startX: void 0,\n    startY: void 0,\n    touchesStart: {},\n    touchesCurrent: {}\n  };\n  const velocity = {\n    x: void 0,\n    y: void 0,\n    prevPositionX: void 0,\n    prevPositionY: void 0,\n    prevTime: void 0\n  };\n  let scale = 1;\n  Object.defineProperty(swiper.zoom, \"scale\", {\n    get() {\n      return scale;\n    },\n    set(value) {\n      if (scale !== value) {\n        const imageEl = gesture.imageEl;\n        const slideEl = gesture.slideEl;\n        emit(\"zoomChange\", value, imageEl, slideEl);\n      }\n      scale = value;\n    }\n  });\n  function getDistanceBetweenTouches() {\n    if (evCache.length < 2)\n      return 1;\n    const x1 = evCache[0].pageX;\n    const y1 = evCache[0].pageY;\n    const x2 = evCache[1].pageX;\n    const y2 = evCache[1].pageY;\n    const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);\n    return distance;\n  }\n  function getScaleOrigin() {\n    if (evCache.length < 2)\n      return {\n        x: null,\n        y: null\n      };\n    const box = gesture.imageEl.getBoundingClientRect();\n    return [(evCache[0].pageX + (evCache[1].pageX - evCache[0].pageX) / 2 - box.x - window.scrollX) / currentScale, (evCache[0].pageY + (evCache[1].pageY - evCache[0].pageY) / 2 - box.y - window.scrollY) / currentScale];\n  }\n  function getSlideSelector() {\n    return swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;\n  }\n  function eventWithinSlide(e) {\n    const slideSelector = getSlideSelector();\n    if (e.target.matches(slideSelector))\n      return true;\n    if (swiper.slides.filter((slideEl) => slideEl.contains(e.target)).length > 0)\n      return true;\n    return false;\n  }\n  function eventWithinZoomContainer(e) {\n    const selector = `.${swiper.params.zoom.containerClass}`;\n    if (e.target.matches(selector))\n      return true;\n    if ([...swiper.hostEl.querySelectorAll(selector)].filter((containerEl) => containerEl.contains(e.target)).length > 0)\n      return true;\n    return false;\n  }\n  function onGestureStart(e) {\n    if (e.pointerType === \"mouse\") {\n      evCache.splice(0, evCache.length);\n    }\n    if (!eventWithinSlide(e))\n      return;\n    const params = swiper.params.zoom;\n    fakeGestureTouched = false;\n    fakeGestureMoved = false;\n    evCache.push(e);\n    if (evCache.length < 2) {\n      return;\n    }\n    fakeGestureTouched = true;\n    gesture.scaleStart = getDistanceBetweenTouches();\n    if (!gesture.slideEl) {\n      gesture.slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);\n      if (!gesture.slideEl)\n        gesture.slideEl = swiper.slides[swiper.activeIndex];\n      let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);\n      if (imageEl) {\n        imageEl = imageEl.querySelectorAll(\"picture, img, svg, canvas, .swiper-zoom-target\")[0];\n      }\n      gesture.imageEl = imageEl;\n      if (imageEl) {\n        gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];\n      } else {\n        gesture.imageWrapEl = void 0;\n      }\n      if (!gesture.imageWrapEl) {\n        gesture.imageEl = void 0;\n        return;\n      }\n      gesture.maxRatio = gesture.imageWrapEl.getAttribute(\"data-swiper-zoom\") || params.maxRatio;\n    }\n    if (gesture.imageEl) {\n      const [originX, originY] = getScaleOrigin();\n      gesture.originX = originX;\n      gesture.originY = originY;\n      gesture.imageEl.style.transitionDuration = \"0ms\";\n    }\n    isScaling = true;\n  }\n  function onGestureChange(e) {\n    if (!eventWithinSlide(e))\n      return;\n    const params = swiper.params.zoom;\n    const zoom = swiper.zoom;\n    const pointerIndex = evCache.findIndex((cachedEv) => cachedEv.pointerId === e.pointerId);\n    if (pointerIndex >= 0)\n      evCache[pointerIndex] = e;\n    if (evCache.length < 2) {\n      return;\n    }\n    fakeGestureMoved = true;\n    gesture.scaleMove = getDistanceBetweenTouches();\n    if (!gesture.imageEl) {\n      return;\n    }\n    zoom.scale = gesture.scaleMove / gesture.scaleStart * currentScale;\n    if (zoom.scale > gesture.maxRatio) {\n      zoom.scale = gesture.maxRatio - 1 + (zoom.scale - gesture.maxRatio + 1) ** 0.5;\n    }\n    if (zoom.scale < params.minRatio) {\n      zoom.scale = params.minRatio + 1 - (params.minRatio - zoom.scale + 1) ** 0.5;\n    }\n    gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;\n  }\n  function onGestureEnd(e) {\n    if (!eventWithinSlide(e))\n      return;\n    if (e.pointerType === \"mouse\" && e.type === \"pointerout\")\n      return;\n    const params = swiper.params.zoom;\n    const zoom = swiper.zoom;\n    const pointerIndex = evCache.findIndex((cachedEv) => cachedEv.pointerId === e.pointerId);\n    if (pointerIndex >= 0)\n      evCache.splice(pointerIndex, 1);\n    if (!fakeGestureTouched || !fakeGestureMoved) {\n      return;\n    }\n    fakeGestureTouched = false;\n    fakeGestureMoved = false;\n    if (!gesture.imageEl)\n      return;\n    zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);\n    gesture.imageEl.style.transitionDuration = `${swiper.params.speed}ms`;\n    gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;\n    currentScale = zoom.scale;\n    isScaling = false;\n    if (zoom.scale > 1 && gesture.slideEl) {\n      gesture.slideEl.classList.add(`${params.zoomedSlideClass}`);\n    } else if (zoom.scale <= 1 && gesture.slideEl) {\n      gesture.slideEl.classList.remove(`${params.zoomedSlideClass}`);\n    }\n    if (zoom.scale === 1) {\n      gesture.originX = 0;\n      gesture.originY = 0;\n      gesture.slideEl = void 0;\n    }\n  }\n  function onTouchStart(e) {\n    const device = swiper.device;\n    if (!gesture.imageEl)\n      return;\n    if (image.isTouched)\n      return;\n    if (device.android && e.cancelable)\n      e.preventDefault();\n    image.isTouched = true;\n    const event = evCache.length > 0 ? evCache[0] : e;\n    image.touchesStart.x = event.pageX;\n    image.touchesStart.y = event.pageY;\n  }\n  function onTouchMove(e) {\n    if (!eventWithinSlide(e) || !eventWithinZoomContainer(e))\n      return;\n    const zoom = swiper.zoom;\n    if (!gesture.imageEl)\n      return;\n    if (!image.isTouched || !gesture.slideEl)\n      return;\n    if (!image.isMoved) {\n      image.width = gesture.imageEl.offsetWidth;\n      image.height = gesture.imageEl.offsetHeight;\n      image.startX = getTranslate(gesture.imageWrapEl, \"x\") || 0;\n      image.startY = getTranslate(gesture.imageWrapEl, \"y\") || 0;\n      gesture.slideWidth = gesture.slideEl.offsetWidth;\n      gesture.slideHeight = gesture.slideEl.offsetHeight;\n      gesture.imageWrapEl.style.transitionDuration = \"0ms\";\n    }\n    const scaledWidth = image.width * zoom.scale;\n    const scaledHeight = image.height * zoom.scale;\n    if (scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight)\n      return;\n    image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);\n    image.maxX = -image.minX;\n    image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);\n    image.maxY = -image.minY;\n    image.touchesCurrent.x = evCache.length > 0 ? evCache[0].pageX : e.pageX;\n    image.touchesCurrent.y = evCache.length > 0 ? evCache[0].pageY : e.pageY;\n    const touchesDiff = Math.max(Math.abs(image.touchesCurrent.x - image.touchesStart.x), Math.abs(image.touchesCurrent.y - image.touchesStart.y));\n    if (touchesDiff > 5) {\n      swiper.allowClick = false;\n    }\n    if (!image.isMoved && !isScaling) {\n      if (swiper.isHorizontal() && (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x || Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)) {\n        image.isTouched = false;\n        return;\n      }\n      if (!swiper.isHorizontal() && (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y || Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)) {\n        image.isTouched = false;\n        return;\n      }\n    }\n    if (e.cancelable) {\n      e.preventDefault();\n    }\n    e.stopPropagation();\n    image.isMoved = true;\n    const scaleRatio = (zoom.scale - currentScale) / (gesture.maxRatio - swiper.params.zoom.minRatio);\n    const {\n      originX,\n      originY\n    } = gesture;\n    image.currentX = image.touchesCurrent.x - image.touchesStart.x + image.startX + scaleRatio * (image.width - originX * 2);\n    image.currentY = image.touchesCurrent.y - image.touchesStart.y + image.startY + scaleRatio * (image.height - originY * 2);\n    if (image.currentX < image.minX) {\n      image.currentX = image.minX + 1 - (image.minX - image.currentX + 1) ** 0.8;\n    }\n    if (image.currentX > image.maxX) {\n      image.currentX = image.maxX - 1 + (image.currentX - image.maxX + 1) ** 0.8;\n    }\n    if (image.currentY < image.minY) {\n      image.currentY = image.minY + 1 - (image.minY - image.currentY + 1) ** 0.8;\n    }\n    if (image.currentY > image.maxY) {\n      image.currentY = image.maxY - 1 + (image.currentY - image.maxY + 1) ** 0.8;\n    }\n    if (!velocity.prevPositionX)\n      velocity.prevPositionX = image.touchesCurrent.x;\n    if (!velocity.prevPositionY)\n      velocity.prevPositionY = image.touchesCurrent.y;\n    if (!velocity.prevTime)\n      velocity.prevTime = Date.now();\n    velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;\n    velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;\n    if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2)\n      velocity.x = 0;\n    if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2)\n      velocity.y = 0;\n    velocity.prevPositionX = image.touchesCurrent.x;\n    velocity.prevPositionY = image.touchesCurrent.y;\n    velocity.prevTime = Date.now();\n    gesture.imageWrapEl.style.transform = `translate3d(${image.currentX}px, ${image.currentY}px,0)`;\n  }\n  function onTouchEnd() {\n    const zoom = swiper.zoom;\n    if (!gesture.imageEl)\n      return;\n    if (!image.isTouched || !image.isMoved) {\n      image.isTouched = false;\n      image.isMoved = false;\n      return;\n    }\n    image.isTouched = false;\n    image.isMoved = false;\n    let momentumDurationX = 300;\n    let momentumDurationY = 300;\n    const momentumDistanceX = velocity.x * momentumDurationX;\n    const newPositionX = image.currentX + momentumDistanceX;\n    const momentumDistanceY = velocity.y * momentumDurationY;\n    const newPositionY = image.currentY + momentumDistanceY;\n    if (velocity.x !== 0)\n      momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);\n    if (velocity.y !== 0)\n      momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);\n    const momentumDuration = Math.max(momentumDurationX, momentumDurationY);\n    image.currentX = newPositionX;\n    image.currentY = newPositionY;\n    const scaledWidth = image.width * zoom.scale;\n    const scaledHeight = image.height * zoom.scale;\n    image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);\n    image.maxX = -image.minX;\n    image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);\n    image.maxY = -image.minY;\n    image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);\n    image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);\n    gesture.imageWrapEl.style.transitionDuration = `${momentumDuration}ms`;\n    gesture.imageWrapEl.style.transform = `translate3d(${image.currentX}px, ${image.currentY}px,0)`;\n  }\n  function onTransitionEnd() {\n    const zoom = swiper.zoom;\n    if (gesture.slideEl && swiper.activeIndex !== swiper.slides.indexOf(gesture.slideEl)) {\n      if (gesture.imageEl) {\n        gesture.imageEl.style.transform = \"translate3d(0,0,0) scale(1)\";\n      }\n      if (gesture.imageWrapEl) {\n        gesture.imageWrapEl.style.transform = \"translate3d(0,0,0)\";\n      }\n      gesture.slideEl.classList.remove(`${swiper.params.zoom.zoomedSlideClass}`);\n      zoom.scale = 1;\n      currentScale = 1;\n      gesture.slideEl = void 0;\n      gesture.imageEl = void 0;\n      gesture.imageWrapEl = void 0;\n      gesture.originX = 0;\n      gesture.originY = 0;\n    }\n  }\n  function zoomIn(e) {\n    const zoom = swiper.zoom;\n    const params = swiper.params.zoom;\n    if (!gesture.slideEl) {\n      if (e && e.target) {\n        gesture.slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);\n      }\n      if (!gesture.slideEl) {\n        if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {\n          gesture.slideEl = elementChildren(swiper.slidesEl, `.${swiper.params.slideActiveClass}`)[0];\n        } else {\n          gesture.slideEl = swiper.slides[swiper.activeIndex];\n        }\n      }\n      let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);\n      if (imageEl) {\n        imageEl = imageEl.querySelectorAll(\"picture, img, svg, canvas, .swiper-zoom-target\")[0];\n      }\n      gesture.imageEl = imageEl;\n      if (imageEl) {\n        gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];\n      } else {\n        gesture.imageWrapEl = void 0;\n      }\n    }\n    if (!gesture.imageEl || !gesture.imageWrapEl)\n      return;\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.style.overflow = \"hidden\";\n      swiper.wrapperEl.style.touchAction = \"none\";\n    }\n    gesture.slideEl.classList.add(`${params.zoomedSlideClass}`);\n    let touchX;\n    let touchY;\n    let offsetX;\n    let offsetY;\n    let diffX;\n    let diffY;\n    let translateX;\n    let translateY;\n    let imageWidth;\n    let imageHeight;\n    let scaledWidth;\n    let scaledHeight;\n    let translateMinX;\n    let translateMinY;\n    let translateMaxX;\n    let translateMaxY;\n    let slideWidth;\n    let slideHeight;\n    if (typeof image.touchesStart.x === \"undefined\" && e) {\n      touchX = e.pageX;\n      touchY = e.pageY;\n    } else {\n      touchX = image.touchesStart.x;\n      touchY = image.touchesStart.y;\n    }\n    const forceZoomRatio = typeof e === \"number\" ? e : null;\n    if (currentScale === 1 && forceZoomRatio) {\n      touchX = void 0;\n      touchY = void 0;\n    }\n    zoom.scale = forceZoomRatio || gesture.imageWrapEl.getAttribute(\"data-swiper-zoom\") || params.maxRatio;\n    currentScale = forceZoomRatio || gesture.imageWrapEl.getAttribute(\"data-swiper-zoom\") || params.maxRatio;\n    if (e && !(currentScale === 1 && forceZoomRatio)) {\n      slideWidth = gesture.slideEl.offsetWidth;\n      slideHeight = gesture.slideEl.offsetHeight;\n      offsetX = elementOffset(gesture.slideEl).left + window.scrollX;\n      offsetY = elementOffset(gesture.slideEl).top + window.scrollY;\n      diffX = offsetX + slideWidth / 2 - touchX;\n      diffY = offsetY + slideHeight / 2 - touchY;\n      imageWidth = gesture.imageEl.offsetWidth;\n      imageHeight = gesture.imageEl.offsetHeight;\n      scaledWidth = imageWidth * zoom.scale;\n      scaledHeight = imageHeight * zoom.scale;\n      translateMinX = Math.min(slideWidth / 2 - scaledWidth / 2, 0);\n      translateMinY = Math.min(slideHeight / 2 - scaledHeight / 2, 0);\n      translateMaxX = -translateMinX;\n      translateMaxY = -translateMinY;\n      translateX = diffX * zoom.scale;\n      translateY = diffY * zoom.scale;\n      if (translateX < translateMinX) {\n        translateX = translateMinX;\n      }\n      if (translateX > translateMaxX) {\n        translateX = translateMaxX;\n      }\n      if (translateY < translateMinY) {\n        translateY = translateMinY;\n      }\n      if (translateY > translateMaxY) {\n        translateY = translateMaxY;\n      }\n    } else {\n      translateX = 0;\n      translateY = 0;\n    }\n    if (forceZoomRatio && zoom.scale === 1) {\n      gesture.originX = 0;\n      gesture.originY = 0;\n    }\n    gesture.imageWrapEl.style.transitionDuration = \"300ms\";\n    gesture.imageWrapEl.style.transform = `translate3d(${translateX}px, ${translateY}px,0)`;\n    gesture.imageEl.style.transitionDuration = \"300ms\";\n    gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;\n  }\n  function zoomOut() {\n    const zoom = swiper.zoom;\n    const params = swiper.params.zoom;\n    if (!gesture.slideEl) {\n      if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {\n        gesture.slideEl = elementChildren(swiper.slidesEl, `.${swiper.params.slideActiveClass}`)[0];\n      } else {\n        gesture.slideEl = swiper.slides[swiper.activeIndex];\n      }\n      let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);\n      if (imageEl) {\n        imageEl = imageEl.querySelectorAll(\"picture, img, svg, canvas, .swiper-zoom-target\")[0];\n      }\n      gesture.imageEl = imageEl;\n      if (imageEl) {\n        gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];\n      } else {\n        gesture.imageWrapEl = void 0;\n      }\n    }\n    if (!gesture.imageEl || !gesture.imageWrapEl)\n      return;\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.style.overflow = \"\";\n      swiper.wrapperEl.style.touchAction = \"\";\n    }\n    zoom.scale = 1;\n    currentScale = 1;\n    gesture.imageWrapEl.style.transitionDuration = \"300ms\";\n    gesture.imageWrapEl.style.transform = \"translate3d(0,0,0)\";\n    gesture.imageEl.style.transitionDuration = \"300ms\";\n    gesture.imageEl.style.transform = \"translate3d(0,0,0) scale(1)\";\n    gesture.slideEl.classList.remove(`${params.zoomedSlideClass}`);\n    gesture.slideEl = void 0;\n    gesture.originX = 0;\n    gesture.originY = 0;\n  }\n  function zoomToggle(e) {\n    const zoom = swiper.zoom;\n    if (zoom.scale && zoom.scale !== 1) {\n      zoomOut();\n    } else {\n      zoomIn(e);\n    }\n  }\n  function getListeners() {\n    const passiveListener = swiper.params.passiveListeners ? {\n      passive: true,\n      capture: false\n    } : false;\n    const activeListenerWithCapture = swiper.params.passiveListeners ? {\n      passive: false,\n      capture: true\n    } : true;\n    return {\n      passiveListener,\n      activeListenerWithCapture\n    };\n  }\n  function enable() {\n    const zoom = swiper.zoom;\n    if (zoom.enabled)\n      return;\n    zoom.enabled = true;\n    const {\n      passiveListener,\n      activeListenerWithCapture\n    } = getListeners();\n    swiper.wrapperEl.addEventListener(\"pointerdown\", onGestureStart, passiveListener);\n    swiper.wrapperEl.addEventListener(\"pointermove\", onGestureChange, activeListenerWithCapture);\n    [\"pointerup\", \"pointercancel\", \"pointerout\"].forEach((eventName) => {\n      swiper.wrapperEl.addEventListener(eventName, onGestureEnd, passiveListener);\n    });\n    swiper.wrapperEl.addEventListener(\"pointermove\", onTouchMove, activeListenerWithCapture);\n  }\n  function disable() {\n    const zoom = swiper.zoom;\n    if (!zoom.enabled)\n      return;\n    zoom.enabled = false;\n    const {\n      passiveListener,\n      activeListenerWithCapture\n    } = getListeners();\n    swiper.wrapperEl.removeEventListener(\"pointerdown\", onGestureStart, passiveListener);\n    swiper.wrapperEl.removeEventListener(\"pointermove\", onGestureChange, activeListenerWithCapture);\n    [\"pointerup\", \"pointercancel\", \"pointerout\"].forEach((eventName) => {\n      swiper.wrapperEl.removeEventListener(eventName, onGestureEnd, passiveListener);\n    });\n    swiper.wrapperEl.removeEventListener(\"pointermove\", onTouchMove, activeListenerWithCapture);\n  }\n  on(\"init\", () => {\n    if (swiper.params.zoom.enabled) {\n      enable();\n    }\n  });\n  on(\"destroy\", () => {\n    disable();\n  });\n  on(\"touchStart\", (_s, e) => {\n    if (!swiper.zoom.enabled)\n      return;\n    onTouchStart(e);\n  });\n  on(\"touchEnd\", (_s, e) => {\n    if (!swiper.zoom.enabled)\n      return;\n    onTouchEnd();\n  });\n  on(\"doubleTap\", (_s, e) => {\n    if (!swiper.animating && swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {\n      zoomToggle(e);\n    }\n  });\n  on(\"transitionEnd\", () => {\n    if (swiper.zoom.enabled && swiper.params.zoom.enabled) {\n      onTransitionEnd();\n    }\n  });\n  on(\"slideChange\", () => {\n    if (swiper.zoom.enabled && swiper.params.zoom.enabled && swiper.params.cssMode) {\n      onTransitionEnd();\n    }\n  });\n  Object.assign(swiper.zoom, {\n    enable,\n    disable,\n    in: zoomIn,\n    out: zoomOut,\n    toggle: zoomToggle\n  });\n}\nexport { Zoom as default };\n",
      "start": 1756100544596,
      "end": 1756100544919,
      "order": "normal",
      "sourcemaps": "{\n  \"version\": 3,\n  \"sources\": [\"/Users/yunhao/Project/website/node_modules/.pnpm/swiper@10.3.1/node_modules/swiper/modules/zoom.mjs\"],\n  \"sourcesContent\": [\"import { a as getWindow } from '../shared/ssr-window.esm.mjs';\\nimport { e as elementChildren, a as elementParents, b as elementOffset, h as getTranslate } from '../shared/utils.mjs';\\n\\nfunction Zoom(_ref) {\\n  let {\\n    swiper,\\n    extendParams,\\n    on,\\n    emit\\n  } = _ref;\\n  const window = getWindow();\\n  extendParams({\\n    zoom: {\\n      enabled: false,\\n      maxRatio: 3,\\n      minRatio: 1,\\n      toggle: true,\\n      containerClass: 'swiper-zoom-container',\\n      zoomedSlideClass: 'swiper-slide-zoomed'\\n    }\\n  });\\n  swiper.zoom = {\\n    enabled: false\\n  };\\n  let currentScale = 1;\\n  let isScaling = false;\\n  let fakeGestureTouched;\\n  let fakeGestureMoved;\\n  const evCache = [];\\n  const gesture = {\\n    originX: 0,\\n    originY: 0,\\n    slideEl: undefined,\\n    slideWidth: undefined,\\n    slideHeight: undefined,\\n    imageEl: undefined,\\n    imageWrapEl: undefined,\\n    maxRatio: 3\\n  };\\n  const image = {\\n    isTouched: undefined,\\n    isMoved: undefined,\\n    currentX: undefined,\\n    currentY: undefined,\\n    minX: undefined,\\n    minY: undefined,\\n    maxX: undefined,\\n    maxY: undefined,\\n    width: undefined,\\n    height: undefined,\\n    startX: undefined,\\n    startY: undefined,\\n    touchesStart: {},\\n    touchesCurrent: {}\\n  };\\n  const velocity = {\\n    x: undefined,\\n    y: undefined,\\n    prevPositionX: undefined,\\n    prevPositionY: undefined,\\n    prevTime: undefined\\n  };\\n  let scale = 1;\\n  Object.defineProperty(swiper.zoom, 'scale', {\\n    get() {\\n      return scale;\\n    },\\n    set(value) {\\n      if (scale !== value) {\\n        const imageEl = gesture.imageEl;\\n        const slideEl = gesture.slideEl;\\n        emit('zoomChange', value, imageEl, slideEl);\\n      }\\n      scale = value;\\n    }\\n  });\\n  function getDistanceBetweenTouches() {\\n    if (evCache.length < 2) return 1;\\n    const x1 = evCache[0].pageX;\\n    const y1 = evCache[0].pageY;\\n    const x2 = evCache[1].pageX;\\n    const y2 = evCache[1].pageY;\\n    const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);\\n    return distance;\\n  }\\n  function getScaleOrigin() {\\n    if (evCache.length < 2) return {\\n      x: null,\\n      y: null\\n    };\\n    const box = gesture.imageEl.getBoundingClientRect();\\n    return [(evCache[0].pageX + (evCache[1].pageX - evCache[0].pageX) / 2 - box.x - window.scrollX) / currentScale, (evCache[0].pageY + (evCache[1].pageY - evCache[0].pageY) / 2 - box.y - window.scrollY) / currentScale];\\n  }\\n  function getSlideSelector() {\\n    return swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;\\n  }\\n  function eventWithinSlide(e) {\\n    const slideSelector = getSlideSelector();\\n    if (e.target.matches(slideSelector)) return true;\\n    if (swiper.slides.filter(slideEl => slideEl.contains(e.target)).length > 0) return true;\\n    return false;\\n  }\\n  function eventWithinZoomContainer(e) {\\n    const selector = `.${swiper.params.zoom.containerClass}`;\\n    if (e.target.matches(selector)) return true;\\n    if ([...swiper.hostEl.querySelectorAll(selector)].filter(containerEl => containerEl.contains(e.target)).length > 0) return true;\\n    return false;\\n  }\\n\\n  // Events\\n  function onGestureStart(e) {\\n    if (e.pointerType === 'mouse') {\\n      evCache.splice(0, evCache.length);\\n    }\\n    if (!eventWithinSlide(e)) return;\\n    const params = swiper.params.zoom;\\n    fakeGestureTouched = false;\\n    fakeGestureMoved = false;\\n    evCache.push(e);\\n    if (evCache.length < 2) {\\n      return;\\n    }\\n    fakeGestureTouched = true;\\n    gesture.scaleStart = getDistanceBetweenTouches();\\n    if (!gesture.slideEl) {\\n      gesture.slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);\\n      if (!gesture.slideEl) gesture.slideEl = swiper.slides[swiper.activeIndex];\\n      let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);\\n      if (imageEl) {\\n        imageEl = imageEl.querySelectorAll('picture, img, svg, canvas, .swiper-zoom-target')[0];\\n      }\\n      gesture.imageEl = imageEl;\\n      if (imageEl) {\\n        gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];\\n      } else {\\n        gesture.imageWrapEl = undefined;\\n      }\\n      if (!gesture.imageWrapEl) {\\n        gesture.imageEl = undefined;\\n        return;\\n      }\\n      gesture.maxRatio = gesture.imageWrapEl.getAttribute('data-swiper-zoom') || params.maxRatio;\\n    }\\n    if (gesture.imageEl) {\\n      const [originX, originY] = getScaleOrigin();\\n      gesture.originX = originX;\\n      gesture.originY = originY;\\n      gesture.imageEl.style.transitionDuration = '0ms';\\n    }\\n    isScaling = true;\\n  }\\n  function onGestureChange(e) {\\n    if (!eventWithinSlide(e)) return;\\n    const params = swiper.params.zoom;\\n    const zoom = swiper.zoom;\\n    const pointerIndex = evCache.findIndex(cachedEv => cachedEv.pointerId === e.pointerId);\\n    if (pointerIndex >= 0) evCache[pointerIndex] = e;\\n    if (evCache.length < 2) {\\n      return;\\n    }\\n    fakeGestureMoved = true;\\n    gesture.scaleMove = getDistanceBetweenTouches();\\n    if (!gesture.imageEl) {\\n      return;\\n    }\\n    zoom.scale = gesture.scaleMove / gesture.scaleStart * currentScale;\\n    if (zoom.scale > gesture.maxRatio) {\\n      zoom.scale = gesture.maxRatio - 1 + (zoom.scale - gesture.maxRatio + 1) ** 0.5;\\n    }\\n    if (zoom.scale < params.minRatio) {\\n      zoom.scale = params.minRatio + 1 - (params.minRatio - zoom.scale + 1) ** 0.5;\\n    }\\n    gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;\\n  }\\n  function onGestureEnd(e) {\\n    if (!eventWithinSlide(e)) return;\\n    if (e.pointerType === 'mouse' && e.type === 'pointerout') return;\\n    const params = swiper.params.zoom;\\n    const zoom = swiper.zoom;\\n    const pointerIndex = evCache.findIndex(cachedEv => cachedEv.pointerId === e.pointerId);\\n    if (pointerIndex >= 0) evCache.splice(pointerIndex, 1);\\n    if (!fakeGestureTouched || !fakeGestureMoved) {\\n      return;\\n    }\\n    fakeGestureTouched = false;\\n    fakeGestureMoved = false;\\n    if (!gesture.imageEl) return;\\n    zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);\\n    gesture.imageEl.style.transitionDuration = `${swiper.params.speed}ms`;\\n    gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;\\n    currentScale = zoom.scale;\\n    isScaling = false;\\n    if (zoom.scale > 1 && gesture.slideEl) {\\n      gesture.slideEl.classList.add(`${params.zoomedSlideClass}`);\\n    } else if (zoom.scale <= 1 && gesture.slideEl) {\\n      gesture.slideEl.classList.remove(`${params.zoomedSlideClass}`);\\n    }\\n    if (zoom.scale === 1) {\\n      gesture.originX = 0;\\n      gesture.originY = 0;\\n      gesture.slideEl = undefined;\\n    }\\n  }\\n  function onTouchStart(e) {\\n    const device = swiper.device;\\n    if (!gesture.imageEl) return;\\n    if (image.isTouched) return;\\n    if (device.android && e.cancelable) e.preventDefault();\\n    image.isTouched = true;\\n    const event = evCache.length > 0 ? evCache[0] : e;\\n    image.touchesStart.x = event.pageX;\\n    image.touchesStart.y = event.pageY;\\n  }\\n  function onTouchMove(e) {\\n    if (!eventWithinSlide(e) || !eventWithinZoomContainer(e)) return;\\n    const zoom = swiper.zoom;\\n    if (!gesture.imageEl) return;\\n    if (!image.isTouched || !gesture.slideEl) return;\\n    if (!image.isMoved) {\\n      image.width = gesture.imageEl.offsetWidth;\\n      image.height = gesture.imageEl.offsetHeight;\\n      image.startX = getTranslate(gesture.imageWrapEl, 'x') || 0;\\n      image.startY = getTranslate(gesture.imageWrapEl, 'y') || 0;\\n      gesture.slideWidth = gesture.slideEl.offsetWidth;\\n      gesture.slideHeight = gesture.slideEl.offsetHeight;\\n      gesture.imageWrapEl.style.transitionDuration = '0ms';\\n    }\\n    // Define if we need image drag\\n    const scaledWidth = image.width * zoom.scale;\\n    const scaledHeight = image.height * zoom.scale;\\n    if (scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight) return;\\n    image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);\\n    image.maxX = -image.minX;\\n    image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);\\n    image.maxY = -image.minY;\\n    image.touchesCurrent.x = evCache.length > 0 ? evCache[0].pageX : e.pageX;\\n    image.touchesCurrent.y = evCache.length > 0 ? evCache[0].pageY : e.pageY;\\n    const touchesDiff = Math.max(Math.abs(image.touchesCurrent.x - image.touchesStart.x), Math.abs(image.touchesCurrent.y - image.touchesStart.y));\\n    if (touchesDiff > 5) {\\n      swiper.allowClick = false;\\n    }\\n    if (!image.isMoved && !isScaling) {\\n      if (swiper.isHorizontal() && (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x || Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)) {\\n        image.isTouched = false;\\n        return;\\n      }\\n      if (!swiper.isHorizontal() && (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y || Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)) {\\n        image.isTouched = false;\\n        return;\\n      }\\n    }\\n    if (e.cancelable) {\\n      e.preventDefault();\\n    }\\n    e.stopPropagation();\\n    image.isMoved = true;\\n    const scaleRatio = (zoom.scale - currentScale) / (gesture.maxRatio - swiper.params.zoom.minRatio);\\n    const {\\n      originX,\\n      originY\\n    } = gesture;\\n    image.currentX = image.touchesCurrent.x - image.touchesStart.x + image.startX + scaleRatio * (image.width - originX * 2);\\n    image.currentY = image.touchesCurrent.y - image.touchesStart.y + image.startY + scaleRatio * (image.height - originY * 2);\\n    if (image.currentX < image.minX) {\\n      image.currentX = image.minX + 1 - (image.minX - image.currentX + 1) ** 0.8;\\n    }\\n    if (image.currentX > image.maxX) {\\n      image.currentX = image.maxX - 1 + (image.currentX - image.maxX + 1) ** 0.8;\\n    }\\n    if (image.currentY < image.minY) {\\n      image.currentY = image.minY + 1 - (image.minY - image.currentY + 1) ** 0.8;\\n    }\\n    if (image.currentY > image.maxY) {\\n      image.currentY = image.maxY - 1 + (image.currentY - image.maxY + 1) ** 0.8;\\n    }\\n\\n    // Velocity\\n    if (!velocity.prevPositionX) velocity.prevPositionX = image.touchesCurrent.x;\\n    if (!velocity.prevPositionY) velocity.prevPositionY = image.touchesCurrent.y;\\n    if (!velocity.prevTime) velocity.prevTime = Date.now();\\n    velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;\\n    velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;\\n    if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) velocity.x = 0;\\n    if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) velocity.y = 0;\\n    velocity.prevPositionX = image.touchesCurrent.x;\\n    velocity.prevPositionY = image.touchesCurrent.y;\\n    velocity.prevTime = Date.now();\\n    gesture.imageWrapEl.style.transform = `translate3d(${image.currentX}px, ${image.currentY}px,0)`;\\n  }\\n  function onTouchEnd() {\\n    const zoom = swiper.zoom;\\n    if (!gesture.imageEl) return;\\n    if (!image.isTouched || !image.isMoved) {\\n      image.isTouched = false;\\n      image.isMoved = false;\\n      return;\\n    }\\n    image.isTouched = false;\\n    image.isMoved = false;\\n    let momentumDurationX = 300;\\n    let momentumDurationY = 300;\\n    const momentumDistanceX = velocity.x * momentumDurationX;\\n    const newPositionX = image.currentX + momentumDistanceX;\\n    const momentumDistanceY = velocity.y * momentumDurationY;\\n    const newPositionY = image.currentY + momentumDistanceY;\\n\\n    // Fix duration\\n    if (velocity.x !== 0) momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);\\n    if (velocity.y !== 0) momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);\\n    const momentumDuration = Math.max(momentumDurationX, momentumDurationY);\\n    image.currentX = newPositionX;\\n    image.currentY = newPositionY;\\n    // Define if we need image drag\\n    const scaledWidth = image.width * zoom.scale;\\n    const scaledHeight = image.height * zoom.scale;\\n    image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);\\n    image.maxX = -image.minX;\\n    image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);\\n    image.maxY = -image.minY;\\n    image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);\\n    image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);\\n    gesture.imageWrapEl.style.transitionDuration = `${momentumDuration}ms`;\\n    gesture.imageWrapEl.style.transform = `translate3d(${image.currentX}px, ${image.currentY}px,0)`;\\n  }\\n  function onTransitionEnd() {\\n    const zoom = swiper.zoom;\\n    if (gesture.slideEl && swiper.activeIndex !== swiper.slides.indexOf(gesture.slideEl)) {\\n      if (gesture.imageEl) {\\n        gesture.imageEl.style.transform = 'translate3d(0,0,0) scale(1)';\\n      }\\n      if (gesture.imageWrapEl) {\\n        gesture.imageWrapEl.style.transform = 'translate3d(0,0,0)';\\n      }\\n      gesture.slideEl.classList.remove(`${swiper.params.zoom.zoomedSlideClass}`);\\n      zoom.scale = 1;\\n      currentScale = 1;\\n      gesture.slideEl = undefined;\\n      gesture.imageEl = undefined;\\n      gesture.imageWrapEl = undefined;\\n      gesture.originX = 0;\\n      gesture.originY = 0;\\n    }\\n  }\\n  function zoomIn(e) {\\n    const zoom = swiper.zoom;\\n    const params = swiper.params.zoom;\\n    if (!gesture.slideEl) {\\n      if (e && e.target) {\\n        gesture.slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);\\n      }\\n      if (!gesture.slideEl) {\\n        if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {\\n          gesture.slideEl = elementChildren(swiper.slidesEl, `.${swiper.params.slideActiveClass}`)[0];\\n        } else {\\n          gesture.slideEl = swiper.slides[swiper.activeIndex];\\n        }\\n      }\\n      let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);\\n      if (imageEl) {\\n        imageEl = imageEl.querySelectorAll('picture, img, svg, canvas, .swiper-zoom-target')[0];\\n      }\\n      gesture.imageEl = imageEl;\\n      if (imageEl) {\\n        gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];\\n      } else {\\n        gesture.imageWrapEl = undefined;\\n      }\\n    }\\n    if (!gesture.imageEl || !gesture.imageWrapEl) return;\\n    if (swiper.params.cssMode) {\\n      swiper.wrapperEl.style.overflow = 'hidden';\\n      swiper.wrapperEl.style.touchAction = 'none';\\n    }\\n    gesture.slideEl.classList.add(`${params.zoomedSlideClass}`);\\n    let touchX;\\n    let touchY;\\n    let offsetX;\\n    let offsetY;\\n    let diffX;\\n    let diffY;\\n    let translateX;\\n    let translateY;\\n    let imageWidth;\\n    let imageHeight;\\n    let scaledWidth;\\n    let scaledHeight;\\n    let translateMinX;\\n    let translateMinY;\\n    let translateMaxX;\\n    let translateMaxY;\\n    let slideWidth;\\n    let slideHeight;\\n    if (typeof image.touchesStart.x === 'undefined' && e) {\\n      touchX = e.pageX;\\n      touchY = e.pageY;\\n    } else {\\n      touchX = image.touchesStart.x;\\n      touchY = image.touchesStart.y;\\n    }\\n    const forceZoomRatio = typeof e === 'number' ? e : null;\\n    if (currentScale === 1 && forceZoomRatio) {\\n      touchX = undefined;\\n      touchY = undefined;\\n    }\\n    zoom.scale = forceZoomRatio || gesture.imageWrapEl.getAttribute('data-swiper-zoom') || params.maxRatio;\\n    currentScale = forceZoomRatio || gesture.imageWrapEl.getAttribute('data-swiper-zoom') || params.maxRatio;\\n    if (e && !(currentScale === 1 && forceZoomRatio)) {\\n      slideWidth = gesture.slideEl.offsetWidth;\\n      slideHeight = gesture.slideEl.offsetHeight;\\n      offsetX = elementOffset(gesture.slideEl).left + window.scrollX;\\n      offsetY = elementOffset(gesture.slideEl).top + window.scrollY;\\n      diffX = offsetX + slideWidth / 2 - touchX;\\n      diffY = offsetY + slideHeight / 2 - touchY;\\n      imageWidth = gesture.imageEl.offsetWidth;\\n      imageHeight = gesture.imageEl.offsetHeight;\\n      scaledWidth = imageWidth * zoom.scale;\\n      scaledHeight = imageHeight * zoom.scale;\\n      translateMinX = Math.min(slideWidth / 2 - scaledWidth / 2, 0);\\n      translateMinY = Math.min(slideHeight / 2 - scaledHeight / 2, 0);\\n      translateMaxX = -translateMinX;\\n      translateMaxY = -translateMinY;\\n      translateX = diffX * zoom.scale;\\n      translateY = diffY * zoom.scale;\\n      if (translateX < translateMinX) {\\n        translateX = translateMinX;\\n      }\\n      if (translateX > translateMaxX) {\\n        translateX = translateMaxX;\\n      }\\n      if (translateY < translateMinY) {\\n        translateY = translateMinY;\\n      }\\n      if (translateY > translateMaxY) {\\n        translateY = translateMaxY;\\n      }\\n    } else {\\n      translateX = 0;\\n      translateY = 0;\\n    }\\n    if (forceZoomRatio && zoom.scale === 1) {\\n      gesture.originX = 0;\\n      gesture.originY = 0;\\n    }\\n    gesture.imageWrapEl.style.transitionDuration = '300ms';\\n    gesture.imageWrapEl.style.transform = `translate3d(${translateX}px, ${translateY}px,0)`;\\n    gesture.imageEl.style.transitionDuration = '300ms';\\n    gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;\\n  }\\n  function zoomOut() {\\n    const zoom = swiper.zoom;\\n    const params = swiper.params.zoom;\\n    if (!gesture.slideEl) {\\n      if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {\\n        gesture.slideEl = elementChildren(swiper.slidesEl, `.${swiper.params.slideActiveClass}`)[0];\\n      } else {\\n        gesture.slideEl = swiper.slides[swiper.activeIndex];\\n      }\\n      let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);\\n      if (imageEl) {\\n        imageEl = imageEl.querySelectorAll('picture, img, svg, canvas, .swiper-zoom-target')[0];\\n      }\\n      gesture.imageEl = imageEl;\\n      if (imageEl) {\\n        gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];\\n      } else {\\n        gesture.imageWrapEl = undefined;\\n      }\\n    }\\n    if (!gesture.imageEl || !gesture.imageWrapEl) return;\\n    if (swiper.params.cssMode) {\\n      swiper.wrapperEl.style.overflow = '';\\n      swiper.wrapperEl.style.touchAction = '';\\n    }\\n    zoom.scale = 1;\\n    currentScale = 1;\\n    gesture.imageWrapEl.style.transitionDuration = '300ms';\\n    gesture.imageWrapEl.style.transform = 'translate3d(0,0,0)';\\n    gesture.imageEl.style.transitionDuration = '300ms';\\n    gesture.imageEl.style.transform = 'translate3d(0,0,0) scale(1)';\\n    gesture.slideEl.classList.remove(`${params.zoomedSlideClass}`);\\n    gesture.slideEl = undefined;\\n    gesture.originX = 0;\\n    gesture.originY = 0;\\n  }\\n\\n  // Toggle Zoom\\n  function zoomToggle(e) {\\n    const zoom = swiper.zoom;\\n    if (zoom.scale && zoom.scale !== 1) {\\n      // Zoom Out\\n      zoomOut();\\n    } else {\\n      // Zoom In\\n      zoomIn(e);\\n    }\\n  }\\n  function getListeners() {\\n    const passiveListener = swiper.params.passiveListeners ? {\\n      passive: true,\\n      capture: false\\n    } : false;\\n    const activeListenerWithCapture = swiper.params.passiveListeners ? {\\n      passive: false,\\n      capture: true\\n    } : true;\\n    return {\\n      passiveListener,\\n      activeListenerWithCapture\\n    };\\n  }\\n\\n  // Attach/Detach Events\\n  function enable() {\\n    const zoom = swiper.zoom;\\n    if (zoom.enabled) return;\\n    zoom.enabled = true;\\n    const {\\n      passiveListener,\\n      activeListenerWithCapture\\n    } = getListeners();\\n\\n    // Scale image\\n    swiper.wrapperEl.addEventListener('pointerdown', onGestureStart, passiveListener);\\n    swiper.wrapperEl.addEventListener('pointermove', onGestureChange, activeListenerWithCapture);\\n    ['pointerup', 'pointercancel', 'pointerout'].forEach(eventName => {\\n      swiper.wrapperEl.addEventListener(eventName, onGestureEnd, passiveListener);\\n    });\\n\\n    // Move image\\n    swiper.wrapperEl.addEventListener('pointermove', onTouchMove, activeListenerWithCapture);\\n  }\\n  function disable() {\\n    const zoom = swiper.zoom;\\n    if (!zoom.enabled) return;\\n    zoom.enabled = false;\\n    const {\\n      passiveListener,\\n      activeListenerWithCapture\\n    } = getListeners();\\n\\n    // Scale image\\n    swiper.wrapperEl.removeEventListener('pointerdown', onGestureStart, passiveListener);\\n    swiper.wrapperEl.removeEventListener('pointermove', onGestureChange, activeListenerWithCapture);\\n    ['pointerup', 'pointercancel', 'pointerout'].forEach(eventName => {\\n      swiper.wrapperEl.removeEventListener(eventName, onGestureEnd, passiveListener);\\n    });\\n\\n    // Move image\\n    swiper.wrapperEl.removeEventListener('pointermove', onTouchMove, activeListenerWithCapture);\\n  }\\n  on('init', () => {\\n    if (swiper.params.zoom.enabled) {\\n      enable();\\n    }\\n  });\\n  on('destroy', () => {\\n    disable();\\n  });\\n  on('touchStart', (_s, e) => {\\n    if (!swiper.zoom.enabled) return;\\n    onTouchStart(e);\\n  });\\n  on('touchEnd', (_s, e) => {\\n    if (!swiper.zoom.enabled) return;\\n    onTouchEnd();\\n  });\\n  on('doubleTap', (_s, e) => {\\n    if (!swiper.animating && swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {\\n      zoomToggle(e);\\n    }\\n  });\\n  on('transitionEnd', () => {\\n    if (swiper.zoom.enabled && swiper.params.zoom.enabled) {\\n      onTransitionEnd();\\n    }\\n  });\\n  on('slideChange', () => {\\n    if (swiper.zoom.enabled && swiper.params.zoom.enabled && swiper.params.cssMode) {\\n      onTransitionEnd();\\n    }\\n  });\\n  Object.assign(swiper.zoom, {\\n    enable,\\n    disable,\\n    in: zoomIn,\\n    out: zoomOut,\\n    toggle: zoomToggle\\n  });\\n}\\n\\nexport { Zoom as default };\\n\"],\n  \"mappings\": \"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\",\n  \"names\": []\n}\n"
    },
    {
      "name": "vite:css-post",
      "start": 1756100544919,
      "end": 1756100544919,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1756100544919,
      "end": 1756100544919,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1756100544919,
      "end": 1756100544919,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1756100544919,
      "end": 1756100544919,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "start": 1756100544919,
      "end": 1756100544919,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1756100544919,
      "end": 1756100544919,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1756100544919,
      "end": 1756100544919,
      "order": "normal"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1756100544919,
      "end": 1756100544919,
      "order": "post"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1756100544919,
      "end": 1756100544919,
      "order": "post"
    },
    {
      "name": "unplugin-vue-components",
      "start": 1756100544919,
      "end": 1756100544919,
      "order": "post"
    },
    {
      "name": "unplugin-vue-components",
      "start": 1756100544919,
      "end": 1756100544919,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1756100544919,
      "end": 1756100544919,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1756100544919,
      "end": 1756100544919,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1756100544919,
      "end": 1756100544919,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1756100544919,
      "end": 1756100544919,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1756100544919,
      "end": 1756100544919,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1756100544919,
      "end": 1756100544919,
      "order": "post"
    },
    {
      "name": "element-plus:transform",
      "start": 1756100544919,
      "end": 1756100544919,
      "order": "post"
    },
    {
      "name": "vant:transform",
      "start": 1756100544919,
      "end": 1756100544919,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-template",
      "start": 1756100544919,
      "end": 1756100544919,
      "order": "post"
    },
    {
      "name": "nuxt:components-loader",
      "start": 1756100544919,
      "end": 1756100544919,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-composables:transform",
      "start": 1756100544919,
      "end": 1756100544919,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1756100544919,
      "end": 1756100544919,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1756100544919,
      "end": 1756100544919,
      "order": "normal"
    }
  ]
}
