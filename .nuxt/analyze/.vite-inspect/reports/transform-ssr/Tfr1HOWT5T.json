{
  "resolvedId": "/Users/yunhao/Project/website/node_modules/.pnpm/swiper@10.3.1/node_modules/swiper/modules/mousewheel.mjs",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "import { a as getWindow } from '../shared/ssr-window.esm.mjs';\nimport { n as nextTick, d as now } from '../shared/utils.mjs';\n\n/* eslint-disable consistent-return */\nfunction Mousewheel(_ref) {\n  let {\n    swiper,\n    extendParams,\n    on,\n    emit\n  } = _ref;\n  const window = getWindow();\n  extendParams({\n    mousewheel: {\n      enabled: false,\n      releaseOnEdges: false,\n      invert: false,\n      forceToAxis: false,\n      sensitivity: 1,\n      eventsTarget: 'container',\n      thresholdDelta: null,\n      thresholdTime: null,\n      noMousewheelClass: 'swiper-no-mousewheel'\n    }\n  });\n  swiper.mousewheel = {\n    enabled: false\n  };\n  let timeout;\n  let lastScrollTime = now();\n  let lastEventBeforeSnap;\n  const recentWheelEvents = [];\n  function normalize(e) {\n    // Reasonable defaults\n    const PIXEL_STEP = 10;\n    const LINE_HEIGHT = 40;\n    const PAGE_HEIGHT = 800;\n    let sX = 0;\n    let sY = 0; // spinX, spinY\n    let pX = 0;\n    let pY = 0; // pixelX, pixelY\n\n    // Legacy\n    if ('detail' in e) {\n      sY = e.detail;\n    }\n    if ('wheelDelta' in e) {\n      sY = -e.wheelDelta / 120;\n    }\n    if ('wheelDeltaY' in e) {\n      sY = -e.wheelDeltaY / 120;\n    }\n    if ('wheelDeltaX' in e) {\n      sX = -e.wheelDeltaX / 120;\n    }\n\n    // side scrolling on FF with DOMMouseScroll\n    if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {\n      sX = sY;\n      sY = 0;\n    }\n    pX = sX * PIXEL_STEP;\n    pY = sY * PIXEL_STEP;\n    if ('deltaY' in e) {\n      pY = e.deltaY;\n    }\n    if ('deltaX' in e) {\n      pX = e.deltaX;\n    }\n    if (e.shiftKey && !pX) {\n      // if user scrolls with shift he wants horizontal scroll\n      pX = pY;\n      pY = 0;\n    }\n    if ((pX || pY) && e.deltaMode) {\n      if (e.deltaMode === 1) {\n        // delta in LINE units\n        pX *= LINE_HEIGHT;\n        pY *= LINE_HEIGHT;\n      } else {\n        // delta in PAGE units\n        pX *= PAGE_HEIGHT;\n        pY *= PAGE_HEIGHT;\n      }\n    }\n\n    // Fall-back if spin cannot be determined\n    if (pX && !sX) {\n      sX = pX < 1 ? -1 : 1;\n    }\n    if (pY && !sY) {\n      sY = pY < 1 ? -1 : 1;\n    }\n    return {\n      spinX: sX,\n      spinY: sY,\n      pixelX: pX,\n      pixelY: pY\n    };\n  }\n  function handleMouseEnter() {\n    if (!swiper.enabled) return;\n    swiper.mouseEntered = true;\n  }\n  function handleMouseLeave() {\n    if (!swiper.enabled) return;\n    swiper.mouseEntered = false;\n  }\n  function animateSlider(newEvent) {\n    if (swiper.params.mousewheel.thresholdDelta && newEvent.delta < swiper.params.mousewheel.thresholdDelta) {\n      // Prevent if delta of wheel scroll delta is below configured threshold\n      return false;\n    }\n    if (swiper.params.mousewheel.thresholdTime && now() - lastScrollTime < swiper.params.mousewheel.thresholdTime) {\n      // Prevent if time between scrolls is below configured threshold\n      return false;\n    }\n\n    // If the movement is NOT big enough and\n    // if the last time the user scrolled was too close to the current one (avoid continuously triggering the slider):\n    //   Don't go any further (avoid insignificant scroll movement).\n    if (newEvent.delta >= 6 && now() - lastScrollTime < 60) {\n      // Return false as a default\n      return true;\n    }\n    // If user is scrolling towards the end:\n    //   If the slider hasn't hit the latest slide or\n    //   if the slider is a loop and\n    //   if the slider isn't moving right now:\n    //     Go to next slide and\n    //     emit a scroll event.\n    // Else (the user is scrolling towards the beginning) and\n    // if the slider hasn't hit the first slide or\n    // if the slider is a loop and\n    // if the slider isn't moving right now:\n    //   Go to prev slide and\n    //   emit a scroll event.\n    if (newEvent.direction < 0) {\n      if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {\n        swiper.slideNext();\n        emit('scroll', newEvent.raw);\n      }\n    } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {\n      swiper.slidePrev();\n      emit('scroll', newEvent.raw);\n    }\n    // If you got here is because an animation has been triggered so store the current time\n    lastScrollTime = new window.Date().getTime();\n    // Return false as a default\n    return false;\n  }\n  function releaseScroll(newEvent) {\n    const params = swiper.params.mousewheel;\n    if (newEvent.direction < 0) {\n      if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {\n        // Return true to animate scroll on edges\n        return true;\n      }\n    } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {\n      // Return true to animate scroll on edges\n      return true;\n    }\n    return false;\n  }\n  function handle(event) {\n    let e = event;\n    let disableParentSwiper = true;\n    if (!swiper.enabled) return;\n\n    // Ignore event if the target or its parents have the swiper-no-mousewheel class\n    if (event.target.closest(`.${swiper.params.mousewheel.noMousewheelClass}`)) return;\n    const params = swiper.params.mousewheel;\n    if (swiper.params.cssMode) {\n      e.preventDefault();\n    }\n    let targetEl = swiper.el;\n    if (swiper.params.mousewheel.eventsTarget !== 'container') {\n      targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);\n    }\n    const targetElContainsTarget = targetEl && targetEl.contains(e.target);\n    if (!swiper.mouseEntered && !targetElContainsTarget && !params.releaseOnEdges) return true;\n    if (e.originalEvent) e = e.originalEvent; // jquery fix\n    let delta = 0;\n    const rtlFactor = swiper.rtlTranslate ? -1 : 1;\n    const data = normalize(e);\n    if (params.forceToAxis) {\n      if (swiper.isHorizontal()) {\n        if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = -data.pixelX * rtlFactor;else return true;\n      } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = -data.pixelY;else return true;\n    } else {\n      delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;\n    }\n    if (delta === 0) return true;\n    if (params.invert) delta = -delta;\n\n    // Get the scroll positions\n    let positions = swiper.getTranslate() + delta * params.sensitivity;\n    if (positions >= swiper.minTranslate()) positions = swiper.minTranslate();\n    if (positions <= swiper.maxTranslate()) positions = swiper.maxTranslate();\n\n    // When loop is true:\n    //     the disableParentSwiper will be true.\n    // When loop is false:\n    //     if the scroll positions is not on edge,\n    //     then the disableParentSwiper will be true.\n    //     if the scroll on edge positions,\n    //     then the disableParentSwiper will be false.\n    disableParentSwiper = swiper.params.loop ? true : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());\n    if (disableParentSwiper && swiper.params.nested) e.stopPropagation();\n    if (!swiper.params.freeMode || !swiper.params.freeMode.enabled) {\n      // Register the new event in a variable which stores the relevant data\n      const newEvent = {\n        time: now(),\n        delta: Math.abs(delta),\n        direction: Math.sign(delta),\n        raw: event\n      };\n\n      // Keep the most recent events\n      if (recentWheelEvents.length >= 2) {\n        recentWheelEvents.shift(); // only store the last N events\n      }\n\n      const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;\n      recentWheelEvents.push(newEvent);\n\n      // If there is at least one previous recorded event:\n      //   If direction has changed or\n      //   if the scroll is quicker than the previous one:\n      //     Animate the slider.\n      // Else (this is the first time the wheel is moved):\n      //     Animate the slider.\n      if (prevEvent) {\n        if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {\n          animateSlider(newEvent);\n        }\n      } else {\n        animateSlider(newEvent);\n      }\n\n      // If it's time to release the scroll:\n      //   Return now so you don't hit the preventDefault.\n      if (releaseScroll(newEvent)) {\n        return true;\n      }\n    } else {\n      // Freemode or scrollContainer:\n\n      // If we recently snapped after a momentum scroll, then ignore wheel events\n      // to give time for the deceleration to finish. Stop ignoring after 500 msecs\n      // or if it's a new scroll (larger delta or inverse sign as last event before\n      // an end-of-momentum snap).\n      const newEvent = {\n        time: now(),\n        delta: Math.abs(delta),\n        direction: Math.sign(delta)\n      };\n      const ignoreWheelEvents = lastEventBeforeSnap && newEvent.time < lastEventBeforeSnap.time + 500 && newEvent.delta <= lastEventBeforeSnap.delta && newEvent.direction === lastEventBeforeSnap.direction;\n      if (!ignoreWheelEvents) {\n        lastEventBeforeSnap = undefined;\n        let position = swiper.getTranslate() + delta * params.sensitivity;\n        const wasBeginning = swiper.isBeginning;\n        const wasEnd = swiper.isEnd;\n        if (position >= swiper.minTranslate()) position = swiper.minTranslate();\n        if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();\n        swiper.setTransition(0);\n        swiper.setTranslate(position);\n        swiper.updateProgress();\n        swiper.updateActiveIndex();\n        swiper.updateSlidesClasses();\n        if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) {\n          swiper.updateSlidesClasses();\n        }\n        if (swiper.params.loop) {\n          swiper.loopFix({\n            direction: newEvent.direction < 0 ? 'next' : 'prev',\n            byMousewheel: true\n          });\n        }\n        if (swiper.params.freeMode.sticky) {\n          // When wheel scrolling starts with sticky (aka snap) enabled, then detect\n          // the end of a momentum scroll by storing recent (N=15?) wheel events.\n          // 1. do all N events have decreasing or same (absolute value) delta?\n          // 2. did all N events arrive in the last M (M=500?) msecs?\n          // 3. does the earliest event have an (absolute value) delta that's\n          //    at least P (P=1?) larger than the most recent event's delta?\n          // 4. does the latest event have a delta that's smaller than Q (Q=6?) pixels?\n          // If 1-4 are \"yes\" then we're near the end of a momentum scroll deceleration.\n          // Snap immediately and ignore remaining wheel events in this scroll.\n          // See comment above for \"remaining wheel events in this scroll\" determination.\n          // If 1-4 aren't satisfied, then wait to snap until 500ms after the last event.\n          clearTimeout(timeout);\n          timeout = undefined;\n          if (recentWheelEvents.length >= 15) {\n            recentWheelEvents.shift(); // only store the last N events\n          }\n\n          const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;\n          const firstEvent = recentWheelEvents[0];\n          recentWheelEvents.push(newEvent);\n          if (prevEvent && (newEvent.delta > prevEvent.delta || newEvent.direction !== prevEvent.direction)) {\n            // Increasing or reverse-sign delta means the user started scrolling again. Clear the wheel event log.\n            recentWheelEvents.splice(0);\n          } else if (recentWheelEvents.length >= 15 && newEvent.time - firstEvent.time < 500 && firstEvent.delta - newEvent.delta >= 1 && newEvent.delta <= 6) {\n            // We're at the end of the deceleration of a momentum scroll, so there's no need\n            // to wait for more events. Snap ASAP on the next tick.\n            // Also, because there's some remaining momentum we'll bias the snap in the\n            // direction of the ongoing scroll because it's better UX for the scroll to snap\n            // in the same direction as the scroll instead of reversing to snap.  Therefore,\n            // if it's already scrolled more than 20% in the current direction, keep going.\n            const snapToThreshold = delta > 0 ? 0.8 : 0.2;\n            lastEventBeforeSnap = newEvent;\n            recentWheelEvents.splice(0);\n            timeout = nextTick(() => {\n              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\n            }, 0); // no delay; move on next tick\n          }\n\n          if (!timeout) {\n            // if we get here, then we haven't detected the end of a momentum scroll, so\n            // we'll consider a scroll \"complete\" when there haven't been any wheel events\n            // for 500ms.\n            timeout = nextTick(() => {\n              const snapToThreshold = 0.5;\n              lastEventBeforeSnap = newEvent;\n              recentWheelEvents.splice(0);\n              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\n            }, 500);\n          }\n        }\n\n        // Emit event\n        if (!ignoreWheelEvents) emit('scroll', e);\n\n        // Stop autoplay\n        if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.autoplay.stop();\n        // Return page scroll on edge positions\n        if (params.releaseOnEdges && (position === swiper.minTranslate() || position === swiper.maxTranslate())) {\n          return true;\n        }\n      }\n    }\n    if (e.preventDefault) e.preventDefault();else e.returnValue = false;\n    return false;\n  }\n  function events(method) {\n    let targetEl = swiper.el;\n    if (swiper.params.mousewheel.eventsTarget !== 'container') {\n      targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);\n    }\n    targetEl[method]('mouseenter', handleMouseEnter);\n    targetEl[method]('mouseleave', handleMouseLeave);\n    targetEl[method]('wheel', handle);\n  }\n  function enable() {\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.removeEventListener('wheel', handle);\n      return true;\n    }\n    if (swiper.mousewheel.enabled) return false;\n    events('addEventListener');\n    swiper.mousewheel.enabled = true;\n    return true;\n  }\n  function disable() {\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.addEventListener(event, handle);\n      return true;\n    }\n    if (!swiper.mousewheel.enabled) return false;\n    events('removeEventListener');\n    swiper.mousewheel.enabled = false;\n    return true;\n  }\n  on('init', () => {\n    if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {\n      disable();\n    }\n    if (swiper.params.mousewheel.enabled) enable();\n  });\n  on('destroy', () => {\n    if (swiper.params.cssMode) {\n      enable();\n    }\n    if (swiper.mousewheel.enabled) disable();\n  });\n  Object.assign(swiper.mousewheel, {\n    enable,\n    disable\n  });\n}\n\nexport { Mousewheel as default };\n",
      "start": 1756100544544,
      "end": 1756100544583,
      "sourcemaps": null
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1756100544583,
      "end": 1756100544583,
      "order": "pre"
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1756100544583,
      "end": 1756100544583,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1756100544583,
      "end": 1756100544583,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1756100544583,
      "end": 1756100544583,
      "order": "pre"
    },
    {
      "name": "nuxt:client-fallback-auto-id",
      "start": 1756100544583,
      "end": 1756100544583,
      "order": "pre"
    },
    {
      "name": "server-only-component-transform",
      "start": 1756100544583,
      "end": 1756100544583,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1756100544583,
      "end": 1756100544583,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1756100544583,
      "end": 1756100544583,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1756100544583,
      "end": 1756100544583,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1756100544583,
      "end": 1756100544583,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1756100544583,
      "end": 1756100544583,
      "order": "normal"
    },
    {
      "name": "vite:vue-jsx",
      "start": 1756100544583,
      "end": 1756100544583,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1756100544583,
      "end": 1756100544583,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1756100544583,
      "end": 1756100544583,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1756100544583,
      "end": 1756100544583,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1756100544583,
      "end": 1756100544583,
      "order": "normal"
    },
    {
      "name": "nuxt:components:imports",
      "start": 1756100544583,
      "end": 1756100544583,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1756100544583,
      "end": 1756100544583,
      "order": "normal"
    },
    {
      "name": "ssr-styles",
      "start": 1756100544583,
      "end": 1756100544584,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "result": "import { a as getWindow } from \"../shared/ssr-window.esm.mjs\";\nimport { n as nextTick, d as now } from \"../shared/utils.mjs\";\nfunction Mousewheel(_ref) {\n  let {\n    swiper,\n    extendParams,\n    on,\n    emit\n  } = _ref;\n  const window = getWindow();\n  extendParams({\n    mousewheel: {\n      enabled: false,\n      releaseOnEdges: false,\n      invert: false,\n      forceToAxis: false,\n      sensitivity: 1,\n      eventsTarget: \"container\",\n      thresholdDelta: null,\n      thresholdTime: null,\n      noMousewheelClass: \"swiper-no-mousewheel\"\n    }\n  });\n  swiper.mousewheel = {\n    enabled: false\n  };\n  let timeout;\n  let lastScrollTime = now();\n  let lastEventBeforeSnap;\n  const recentWheelEvents = [];\n  function normalize(e) {\n    const PIXEL_STEP = 10;\n    const LINE_HEIGHT = 40;\n    const PAGE_HEIGHT = 800;\n    let sX = 0;\n    let sY = 0;\n    let pX = 0;\n    let pY = 0;\n    if (\"detail\" in e) {\n      sY = e.detail;\n    }\n    if (\"wheelDelta\" in e) {\n      sY = -e.wheelDelta / 120;\n    }\n    if (\"wheelDeltaY\" in e) {\n      sY = -e.wheelDeltaY / 120;\n    }\n    if (\"wheelDeltaX\" in e) {\n      sX = -e.wheelDeltaX / 120;\n    }\n    if (\"axis\" in e && e.axis === e.HORIZONTAL_AXIS) {\n      sX = sY;\n      sY = 0;\n    }\n    pX = sX * PIXEL_STEP;\n    pY = sY * PIXEL_STEP;\n    if (\"deltaY\" in e) {\n      pY = e.deltaY;\n    }\n    if (\"deltaX\" in e) {\n      pX = e.deltaX;\n    }\n    if (e.shiftKey && !pX) {\n      pX = pY;\n      pY = 0;\n    }\n    if ((pX || pY) && e.deltaMode) {\n      if (e.deltaMode === 1) {\n        pX *= LINE_HEIGHT;\n        pY *= LINE_HEIGHT;\n      } else {\n        pX *= PAGE_HEIGHT;\n        pY *= PAGE_HEIGHT;\n      }\n    }\n    if (pX && !sX) {\n      sX = pX < 1 ? -1 : 1;\n    }\n    if (pY && !sY) {\n      sY = pY < 1 ? -1 : 1;\n    }\n    return {\n      spinX: sX,\n      spinY: sY,\n      pixelX: pX,\n      pixelY: pY\n    };\n  }\n  function handleMouseEnter() {\n    if (!swiper.enabled)\n      return;\n    swiper.mouseEntered = true;\n  }\n  function handleMouseLeave() {\n    if (!swiper.enabled)\n      return;\n    swiper.mouseEntered = false;\n  }\n  function animateSlider(newEvent) {\n    if (swiper.params.mousewheel.thresholdDelta && newEvent.delta < swiper.params.mousewheel.thresholdDelta) {\n      return false;\n    }\n    if (swiper.params.mousewheel.thresholdTime && now() - lastScrollTime < swiper.params.mousewheel.thresholdTime) {\n      return false;\n    }\n    if (newEvent.delta >= 6 && now() - lastScrollTime < 60) {\n      return true;\n    }\n    if (newEvent.direction < 0) {\n      if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {\n        swiper.slideNext();\n        emit(\"scroll\", newEvent.raw);\n      }\n    } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {\n      swiper.slidePrev();\n      emit(\"scroll\", newEvent.raw);\n    }\n    lastScrollTime = new window.Date().getTime();\n    return false;\n  }\n  function releaseScroll(newEvent) {\n    const params = swiper.params.mousewheel;\n    if (newEvent.direction < 0) {\n      if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {\n        return true;\n      }\n    } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {\n      return true;\n    }\n    return false;\n  }\n  function handle(event2) {\n    let e = event2;\n    let disableParentSwiper = true;\n    if (!swiper.enabled)\n      return;\n    if (event2.target.closest(`.${swiper.params.mousewheel.noMousewheelClass}`))\n      return;\n    const params = swiper.params.mousewheel;\n    if (swiper.params.cssMode) {\n      e.preventDefault();\n    }\n    let targetEl = swiper.el;\n    if (swiper.params.mousewheel.eventsTarget !== \"container\") {\n      targetEl = (void 0).querySelector(swiper.params.mousewheel.eventsTarget);\n    }\n    const targetElContainsTarget = targetEl && targetEl.contains(e.target);\n    if (!swiper.mouseEntered && !targetElContainsTarget && !params.releaseOnEdges)\n      return true;\n    if (e.originalEvent)\n      e = e.originalEvent;\n    let delta = 0;\n    const rtlFactor = swiper.rtlTranslate ? -1 : 1;\n    const data = normalize(e);\n    if (params.forceToAxis) {\n      if (swiper.isHorizontal()) {\n        if (Math.abs(data.pixelX) > Math.abs(data.pixelY))\n          delta = -data.pixelX * rtlFactor;\n        else\n          return true;\n      } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX))\n        delta = -data.pixelY;\n      else\n        return true;\n    } else {\n      delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;\n    }\n    if (delta === 0)\n      return true;\n    if (params.invert)\n      delta = -delta;\n    let positions = swiper.getTranslate() + delta * params.sensitivity;\n    if (positions >= swiper.minTranslate())\n      positions = swiper.minTranslate();\n    if (positions <= swiper.maxTranslate())\n      positions = swiper.maxTranslate();\n    disableParentSwiper = swiper.params.loop ? true : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());\n    if (disableParentSwiper && swiper.params.nested)\n      e.stopPropagation();\n    if (!swiper.params.freeMode || !swiper.params.freeMode.enabled) {\n      const newEvent = {\n        time: now(),\n        delta: Math.abs(delta),\n        direction: Math.sign(delta),\n        raw: event2\n      };\n      if (recentWheelEvents.length >= 2) {\n        recentWheelEvents.shift();\n      }\n      const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : void 0;\n      recentWheelEvents.push(newEvent);\n      if (prevEvent) {\n        if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {\n          animateSlider(newEvent);\n        }\n      } else {\n        animateSlider(newEvent);\n      }\n      if (releaseScroll(newEvent)) {\n        return true;\n      }\n    } else {\n      const newEvent = {\n        time: now(),\n        delta: Math.abs(delta),\n        direction: Math.sign(delta)\n      };\n      const ignoreWheelEvents = lastEventBeforeSnap && newEvent.time < lastEventBeforeSnap.time + 500 && newEvent.delta <= lastEventBeforeSnap.delta && newEvent.direction === lastEventBeforeSnap.direction;\n      if (!ignoreWheelEvents) {\n        lastEventBeforeSnap = void 0;\n        let position = swiper.getTranslate() + delta * params.sensitivity;\n        const wasBeginning = swiper.isBeginning;\n        const wasEnd = swiper.isEnd;\n        if (position >= swiper.minTranslate())\n          position = swiper.minTranslate();\n        if (position <= swiper.maxTranslate())\n          position = swiper.maxTranslate();\n        swiper.setTransition(0);\n        swiper.setTranslate(position);\n        swiper.updateProgress();\n        swiper.updateActiveIndex();\n        swiper.updateSlidesClasses();\n        if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) {\n          swiper.updateSlidesClasses();\n        }\n        if (swiper.params.loop) {\n          swiper.loopFix({\n            direction: newEvent.direction < 0 ? \"next\" : \"prev\",\n            byMousewheel: true\n          });\n        }\n        if (swiper.params.freeMode.sticky) {\n          clearTimeout(timeout);\n          timeout = void 0;\n          if (recentWheelEvents.length >= 15) {\n            recentWheelEvents.shift();\n          }\n          const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : void 0;\n          const firstEvent = recentWheelEvents[0];\n          recentWheelEvents.push(newEvent);\n          if (prevEvent && (newEvent.delta > prevEvent.delta || newEvent.direction !== prevEvent.direction)) {\n            recentWheelEvents.splice(0);\n          } else if (recentWheelEvents.length >= 15 && newEvent.time - firstEvent.time < 500 && firstEvent.delta - newEvent.delta >= 1 && newEvent.delta <= 6) {\n            const snapToThreshold = delta > 0 ? 0.8 : 0.2;\n            lastEventBeforeSnap = newEvent;\n            recentWheelEvents.splice(0);\n            timeout = nextTick(() => {\n              swiper.slideToClosest(swiper.params.speed, true, void 0, snapToThreshold);\n            }, 0);\n          }\n          if (!timeout) {\n            timeout = nextTick(() => {\n              const snapToThreshold = 0.5;\n              lastEventBeforeSnap = newEvent;\n              recentWheelEvents.splice(0);\n              swiper.slideToClosest(swiper.params.speed, true, void 0, snapToThreshold);\n            }, 500);\n          }\n        }\n        if (!ignoreWheelEvents)\n          emit(\"scroll\", e);\n        if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction)\n          swiper.autoplay.stop();\n        if (params.releaseOnEdges && (position === swiper.minTranslate() || position === swiper.maxTranslate())) {\n          return true;\n        }\n      }\n    }\n    if (e.preventDefault)\n      e.preventDefault();\n    else\n      e.returnValue = false;\n    return false;\n  }\n  function events(method) {\n    let targetEl = swiper.el;\n    if (swiper.params.mousewheel.eventsTarget !== \"container\") {\n      targetEl = (void 0).querySelector(swiper.params.mousewheel.eventsTarget);\n    }\n    targetEl[method](\"mouseenter\", handleMouseEnter);\n    targetEl[method](\"mouseleave\", handleMouseLeave);\n    targetEl[method](\"wheel\", handle);\n  }\n  function enable() {\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.removeEventListener(\"wheel\", handle);\n      return true;\n    }\n    if (swiper.mousewheel.enabled)\n      return false;\n    events(\"addEventListener\");\n    swiper.mousewheel.enabled = true;\n    return true;\n  }\n  function disable() {\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.addEventListener(event, handle);\n      return true;\n    }\n    if (!swiper.mousewheel.enabled)\n      return false;\n    events(\"removeEventListener\");\n    swiper.mousewheel.enabled = false;\n    return true;\n  }\n  on(\"init\", () => {\n    if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {\n      disable();\n    }\n    if (swiper.params.mousewheel.enabled)\n      enable();\n  });\n  on(\"destroy\", () => {\n    if (swiper.params.cssMode) {\n      enable();\n    }\n    if (swiper.mousewheel.enabled)\n      disable();\n  });\n  Object.assign(swiper.mousewheel, {\n    enable,\n    disable\n  });\n}\nexport { Mousewheel as default };\n",
      "start": 1756100544584,
      "end": 1756100544907,
      "order": "normal",
      "sourcemaps": "{\n  \"version\": 3,\n  \"sources\": [\"/Users/yunhao/Project/website/node_modules/.pnpm/swiper@10.3.1/node_modules/swiper/modules/mousewheel.mjs\"],\n  \"sourcesContent\": [\"import { a as getWindow } from '../shared/ssr-window.esm.mjs';\\nimport { n as nextTick, d as now } from '../shared/utils.mjs';\\n\\n/* eslint-disable consistent-return */\\nfunction Mousewheel(_ref) {\\n  let {\\n    swiper,\\n    extendParams,\\n    on,\\n    emit\\n  } = _ref;\\n  const window = getWindow();\\n  extendParams({\\n    mousewheel: {\\n      enabled: false,\\n      releaseOnEdges: false,\\n      invert: false,\\n      forceToAxis: false,\\n      sensitivity: 1,\\n      eventsTarget: 'container',\\n      thresholdDelta: null,\\n      thresholdTime: null,\\n      noMousewheelClass: 'swiper-no-mousewheel'\\n    }\\n  });\\n  swiper.mousewheel = {\\n    enabled: false\\n  };\\n  let timeout;\\n  let lastScrollTime = now();\\n  let lastEventBeforeSnap;\\n  const recentWheelEvents = [];\\n  function normalize(e) {\\n    // Reasonable defaults\\n    const PIXEL_STEP = 10;\\n    const LINE_HEIGHT = 40;\\n    const PAGE_HEIGHT = 800;\\n    let sX = 0;\\n    let sY = 0; // spinX, spinY\\n    let pX = 0;\\n    let pY = 0; // pixelX, pixelY\\n\\n    // Legacy\\n    if ('detail' in e) {\\n      sY = e.detail;\\n    }\\n    if ('wheelDelta' in e) {\\n      sY = -e.wheelDelta / 120;\\n    }\\n    if ('wheelDeltaY' in e) {\\n      sY = -e.wheelDeltaY / 120;\\n    }\\n    if ('wheelDeltaX' in e) {\\n      sX = -e.wheelDeltaX / 120;\\n    }\\n\\n    // side scrolling on FF with DOMMouseScroll\\n    if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {\\n      sX = sY;\\n      sY = 0;\\n    }\\n    pX = sX * PIXEL_STEP;\\n    pY = sY * PIXEL_STEP;\\n    if ('deltaY' in e) {\\n      pY = e.deltaY;\\n    }\\n    if ('deltaX' in e) {\\n      pX = e.deltaX;\\n    }\\n    if (e.shiftKey && !pX) {\\n      // if user scrolls with shift he wants horizontal scroll\\n      pX = pY;\\n      pY = 0;\\n    }\\n    if ((pX || pY) && e.deltaMode) {\\n      if (e.deltaMode === 1) {\\n        // delta in LINE units\\n        pX *= LINE_HEIGHT;\\n        pY *= LINE_HEIGHT;\\n      } else {\\n        // delta in PAGE units\\n        pX *= PAGE_HEIGHT;\\n        pY *= PAGE_HEIGHT;\\n      }\\n    }\\n\\n    // Fall-back if spin cannot be determined\\n    if (pX && !sX) {\\n      sX = pX < 1 ? -1 : 1;\\n    }\\n    if (pY && !sY) {\\n      sY = pY < 1 ? -1 : 1;\\n    }\\n    return {\\n      spinX: sX,\\n      spinY: sY,\\n      pixelX: pX,\\n      pixelY: pY\\n    };\\n  }\\n  function handleMouseEnter() {\\n    if (!swiper.enabled) return;\\n    swiper.mouseEntered = true;\\n  }\\n  function handleMouseLeave() {\\n    if (!swiper.enabled) return;\\n    swiper.mouseEntered = false;\\n  }\\n  function animateSlider(newEvent) {\\n    if (swiper.params.mousewheel.thresholdDelta && newEvent.delta < swiper.params.mousewheel.thresholdDelta) {\\n      // Prevent if delta of wheel scroll delta is below configured threshold\\n      return false;\\n    }\\n    if (swiper.params.mousewheel.thresholdTime && now() - lastScrollTime < swiper.params.mousewheel.thresholdTime) {\\n      // Prevent if time between scrolls is below configured threshold\\n      return false;\\n    }\\n\\n    // If the movement is NOT big enough and\\n    // if the last time the user scrolled was too close to the current one (avoid continuously triggering the slider):\\n    //   Don't go any further (avoid insignificant scroll movement).\\n    if (newEvent.delta >= 6 && now() - lastScrollTime < 60) {\\n      // Return false as a default\\n      return true;\\n    }\\n    // If user is scrolling towards the end:\\n    //   If the slider hasn't hit the latest slide or\\n    //   if the slider is a loop and\\n    //   if the slider isn't moving right now:\\n    //     Go to next slide and\\n    //     emit a scroll event.\\n    // Else (the user is scrolling towards the beginning) and\\n    // if the slider hasn't hit the first slide or\\n    // if the slider is a loop and\\n    // if the slider isn't moving right now:\\n    //   Go to prev slide and\\n    //   emit a scroll event.\\n    if (newEvent.direction < 0) {\\n      if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {\\n        swiper.slideNext();\\n        emit('scroll', newEvent.raw);\\n      }\\n    } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {\\n      swiper.slidePrev();\\n      emit('scroll', newEvent.raw);\\n    }\\n    // If you got here is because an animation has been triggered so store the current time\\n    lastScrollTime = new window.Date().getTime();\\n    // Return false as a default\\n    return false;\\n  }\\n  function releaseScroll(newEvent) {\\n    const params = swiper.params.mousewheel;\\n    if (newEvent.direction < 0) {\\n      if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {\\n        // Return true to animate scroll on edges\\n        return true;\\n      }\\n    } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {\\n      // Return true to animate scroll on edges\\n      return true;\\n    }\\n    return false;\\n  }\\n  function handle(event) {\\n    let e = event;\\n    let disableParentSwiper = true;\\n    if (!swiper.enabled) return;\\n\\n    // Ignore event if the target or its parents have the swiper-no-mousewheel class\\n    if (event.target.closest(`.${swiper.params.mousewheel.noMousewheelClass}`)) return;\\n    const params = swiper.params.mousewheel;\\n    if (swiper.params.cssMode) {\\n      e.preventDefault();\\n    }\\n    let targetEl = swiper.el;\\n    if (swiper.params.mousewheel.eventsTarget !== 'container') {\\n      targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);\\n    }\\n    const targetElContainsTarget = targetEl && targetEl.contains(e.target);\\n    if (!swiper.mouseEntered && !targetElContainsTarget && !params.releaseOnEdges) return true;\\n    if (e.originalEvent) e = e.originalEvent; // jquery fix\\n    let delta = 0;\\n    const rtlFactor = swiper.rtlTranslate ? -1 : 1;\\n    const data = normalize(e);\\n    if (params.forceToAxis) {\\n      if (swiper.isHorizontal()) {\\n        if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = -data.pixelX * rtlFactor;else return true;\\n      } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = -data.pixelY;else return true;\\n    } else {\\n      delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;\\n    }\\n    if (delta === 0) return true;\\n    if (params.invert) delta = -delta;\\n\\n    // Get the scroll positions\\n    let positions = swiper.getTranslate() + delta * params.sensitivity;\\n    if (positions >= swiper.minTranslate()) positions = swiper.minTranslate();\\n    if (positions <= swiper.maxTranslate()) positions = swiper.maxTranslate();\\n\\n    // When loop is true:\\n    //     the disableParentSwiper will be true.\\n    // When loop is false:\\n    //     if the scroll positions is not on edge,\\n    //     then the disableParentSwiper will be true.\\n    //     if the scroll on edge positions,\\n    //     then the disableParentSwiper will be false.\\n    disableParentSwiper = swiper.params.loop ? true : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());\\n    if (disableParentSwiper && swiper.params.nested) e.stopPropagation();\\n    if (!swiper.params.freeMode || !swiper.params.freeMode.enabled) {\\n      // Register the new event in a variable which stores the relevant data\\n      const newEvent = {\\n        time: now(),\\n        delta: Math.abs(delta),\\n        direction: Math.sign(delta),\\n        raw: event\\n      };\\n\\n      // Keep the most recent events\\n      if (recentWheelEvents.length >= 2) {\\n        recentWheelEvents.shift(); // only store the last N events\\n      }\\n\\n      const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;\\n      recentWheelEvents.push(newEvent);\\n\\n      // If there is at least one previous recorded event:\\n      //   If direction has changed or\\n      //   if the scroll is quicker than the previous one:\\n      //     Animate the slider.\\n      // Else (this is the first time the wheel is moved):\\n      //     Animate the slider.\\n      if (prevEvent) {\\n        if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {\\n          animateSlider(newEvent);\\n        }\\n      } else {\\n        animateSlider(newEvent);\\n      }\\n\\n      // If it's time to release the scroll:\\n      //   Return now so you don't hit the preventDefault.\\n      if (releaseScroll(newEvent)) {\\n        return true;\\n      }\\n    } else {\\n      // Freemode or scrollContainer:\\n\\n      // If we recently snapped after a momentum scroll, then ignore wheel events\\n      // to give time for the deceleration to finish. Stop ignoring after 500 msecs\\n      // or if it's a new scroll (larger delta or inverse sign as last event before\\n      // an end-of-momentum snap).\\n      const newEvent = {\\n        time: now(),\\n        delta: Math.abs(delta),\\n        direction: Math.sign(delta)\\n      };\\n      const ignoreWheelEvents = lastEventBeforeSnap && newEvent.time < lastEventBeforeSnap.time + 500 && newEvent.delta <= lastEventBeforeSnap.delta && newEvent.direction === lastEventBeforeSnap.direction;\\n      if (!ignoreWheelEvents) {\\n        lastEventBeforeSnap = undefined;\\n        let position = swiper.getTranslate() + delta * params.sensitivity;\\n        const wasBeginning = swiper.isBeginning;\\n        const wasEnd = swiper.isEnd;\\n        if (position >= swiper.minTranslate()) position = swiper.minTranslate();\\n        if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();\\n        swiper.setTransition(0);\\n        swiper.setTranslate(position);\\n        swiper.updateProgress();\\n        swiper.updateActiveIndex();\\n        swiper.updateSlidesClasses();\\n        if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) {\\n          swiper.updateSlidesClasses();\\n        }\\n        if (swiper.params.loop) {\\n          swiper.loopFix({\\n            direction: newEvent.direction < 0 ? 'next' : 'prev',\\n            byMousewheel: true\\n          });\\n        }\\n        if (swiper.params.freeMode.sticky) {\\n          // When wheel scrolling starts with sticky (aka snap) enabled, then detect\\n          // the end of a momentum scroll by storing recent (N=15?) wheel events.\\n          // 1. do all N events have decreasing or same (absolute value) delta?\\n          // 2. did all N events arrive in the last M (M=500?) msecs?\\n          // 3. does the earliest event have an (absolute value) delta that's\\n          //    at least P (P=1?) larger than the most recent event's delta?\\n          // 4. does the latest event have a delta that's smaller than Q (Q=6?) pixels?\\n          // If 1-4 are \\\"yes\\\" then we're near the end of a momentum scroll deceleration.\\n          // Snap immediately and ignore remaining wheel events in this scroll.\\n          // See comment above for \\\"remaining wheel events in this scroll\\\" determination.\\n          // If 1-4 aren't satisfied, then wait to snap until 500ms after the last event.\\n          clearTimeout(timeout);\\n          timeout = undefined;\\n          if (recentWheelEvents.length >= 15) {\\n            recentWheelEvents.shift(); // only store the last N events\\n          }\\n\\n          const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;\\n          const firstEvent = recentWheelEvents[0];\\n          recentWheelEvents.push(newEvent);\\n          if (prevEvent && (newEvent.delta > prevEvent.delta || newEvent.direction !== prevEvent.direction)) {\\n            // Increasing or reverse-sign delta means the user started scrolling again. Clear the wheel event log.\\n            recentWheelEvents.splice(0);\\n          } else if (recentWheelEvents.length >= 15 && newEvent.time - firstEvent.time < 500 && firstEvent.delta - newEvent.delta >= 1 && newEvent.delta <= 6) {\\n            // We're at the end of the deceleration of a momentum scroll, so there's no need\\n            // to wait for more events. Snap ASAP on the next tick.\\n            // Also, because there's some remaining momentum we'll bias the snap in the\\n            // direction of the ongoing scroll because it's better UX for the scroll to snap\\n            // in the same direction as the scroll instead of reversing to snap.  Therefore,\\n            // if it's already scrolled more than 20% in the current direction, keep going.\\n            const snapToThreshold = delta > 0 ? 0.8 : 0.2;\\n            lastEventBeforeSnap = newEvent;\\n            recentWheelEvents.splice(0);\\n            timeout = nextTick(() => {\\n              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\\n            }, 0); // no delay; move on next tick\\n          }\\n\\n          if (!timeout) {\\n            // if we get here, then we haven't detected the end of a momentum scroll, so\\n            // we'll consider a scroll \\\"complete\\\" when there haven't been any wheel events\\n            // for 500ms.\\n            timeout = nextTick(() => {\\n              const snapToThreshold = 0.5;\\n              lastEventBeforeSnap = newEvent;\\n              recentWheelEvents.splice(0);\\n              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\\n            }, 500);\\n          }\\n        }\\n\\n        // Emit event\\n        if (!ignoreWheelEvents) emit('scroll', e);\\n\\n        // Stop autoplay\\n        if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.autoplay.stop();\\n        // Return page scroll on edge positions\\n        if (params.releaseOnEdges && (position === swiper.minTranslate() || position === swiper.maxTranslate())) {\\n          return true;\\n        }\\n      }\\n    }\\n    if (e.preventDefault) e.preventDefault();else e.returnValue = false;\\n    return false;\\n  }\\n  function events(method) {\\n    let targetEl = swiper.el;\\n    if (swiper.params.mousewheel.eventsTarget !== 'container') {\\n      targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);\\n    }\\n    targetEl[method]('mouseenter', handleMouseEnter);\\n    targetEl[method]('mouseleave', handleMouseLeave);\\n    targetEl[method]('wheel', handle);\\n  }\\n  function enable() {\\n    if (swiper.params.cssMode) {\\n      swiper.wrapperEl.removeEventListener('wheel', handle);\\n      return true;\\n    }\\n    if (swiper.mousewheel.enabled) return false;\\n    events('addEventListener');\\n    swiper.mousewheel.enabled = true;\\n    return true;\\n  }\\n  function disable() {\\n    if (swiper.params.cssMode) {\\n      swiper.wrapperEl.addEventListener(event, handle);\\n      return true;\\n    }\\n    if (!swiper.mousewheel.enabled) return false;\\n    events('removeEventListener');\\n    swiper.mousewheel.enabled = false;\\n    return true;\\n  }\\n  on('init', () => {\\n    if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {\\n      disable();\\n    }\\n    if (swiper.params.mousewheel.enabled) enable();\\n  });\\n  on('destroy', () => {\\n    if (swiper.params.cssMode) {\\n      enable();\\n    }\\n    if (swiper.mousewheel.enabled) disable();\\n  });\\n  Object.assign(swiper.mousewheel, {\\n    enable,\\n    disable\\n  });\\n}\\n\\nexport { Mousewheel as default };\\n\"],\n  \"mappings\": \"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\",\n  \"names\": [\"event\"]\n}\n"
    },
    {
      "name": "vite:css-post",
      "start": 1756100544907,
      "end": 1756100544907,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1756100544907,
      "end": 1756100544907,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1756100544907,
      "end": 1756100544907,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1756100544907,
      "end": 1756100544907,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "start": 1756100544907,
      "end": 1756100544907,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1756100544907,
      "end": 1756100544907,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1756100544907,
      "end": 1756100544907,
      "order": "normal"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1756100544907,
      "end": 1756100544907,
      "order": "post"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1756100544907,
      "end": 1756100544907,
      "order": "post"
    },
    {
      "name": "unplugin-vue-components",
      "start": 1756100544907,
      "end": 1756100544907,
      "order": "post"
    },
    {
      "name": "unplugin-vue-components",
      "start": 1756100544907,
      "end": 1756100544907,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1756100544907,
      "end": 1756100544907,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1756100544907,
      "end": 1756100544907,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1756100544907,
      "end": 1756100544907,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1756100544907,
      "end": 1756100544907,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1756100544907,
      "end": 1756100544907,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1756100544907,
      "end": 1756100544907,
      "order": "post"
    },
    {
      "name": "element-plus:transform",
      "start": 1756100544907,
      "end": 1756100544907,
      "order": "post"
    },
    {
      "name": "vant:transform",
      "start": 1756100544907,
      "end": 1756100544907,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-template",
      "start": 1756100544907,
      "end": 1756100544907,
      "order": "post"
    },
    {
      "name": "nuxt:components-loader",
      "start": 1756100544907,
      "end": 1756100544907,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-composables:transform",
      "start": 1756100544907,
      "end": 1756100544907,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1756100544907,
      "end": 1756100544907,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1756100544907,
      "end": 1756100544907,
      "order": "normal"
    }
  ]
}
